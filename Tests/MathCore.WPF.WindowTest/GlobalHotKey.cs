using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows.Input;
using System.Windows.Interop;

namespace MathCore.WPF.WindowTest;

public class GlobalHotKey : IDisposable
{
    /// <summary>Define a system-wide hot key.</summary>
    /// <param name="hWnd">
    /// A handle to the window that will receive WM_HOTKEY messages generated by the
    /// hot key. If this parameter is NULL, WM_HOTKEY messages are posted to the
    /// message queue of the calling thread and must be processed in the message loop.
    /// </param>
    /// <param name="id">
    /// The identifier of the hot key. If the hWnd parameter is NULL, then the hot
    /// key is associated with the current thread rather than with a particular
    /// window.
    /// </param>
    /// <param name="modifiers">
    /// The keys that must be pressed in combination with the key specified by the
    /// uVirtKey parameter in order to generate the WM_HOTKEY message. The fsModifiers
    /// parameter can be a combination of the following values.
    /// MOD_ALT     0x0001
    /// MOD_CONTROL 0x0002
    /// MOD_SHIFT   0x0004
    /// MOD_WIN     0x0008
    /// </param>
    /// <param name="key">The virtual-key code of the hot key.</param>
    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern bool RegisterHotKey(IntPtr hWnd, int id, ModifierKeys modifiers, Keys key);

    /// <summary>Frees a hot key previously registered by the calling thread.</summary>
    /// <param name="hWnd">
    /// A handle to the window associated with the hot key to be freed. This parameter
    /// should be NULL if the hot key is not associated with a window.
    /// </param>
    /// <param name="id">
    /// The identifier of the hot key to be freed.
    /// </param>
    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern bool UnregisterHotKey(IntPtr hWnd, int id);

    [DllImport("kernel32.dll")]
    private static extern ushort GlobalAddAtom(string name);

    [DllImport("kernel32.dll")]
    private static extern ushort GlobalDeleteAtom(ushort atom);

    public static (Keys Key, ModifierKeys Modifer) GetModifiers(Keys Key)
    {
        var key      = Key;
        var modifers = ModifierKeys.None;

        if ((Key & Keys.Control) == Keys.Control)
        {
            modifers |= ModifierKeys.Control;
            key      ^= Keys.Control;
        }

        if ((Key & Keys.Shift) == Keys.Shift)
        {
            modifers |= ModifierKeys.Shift;
            key      ^= Keys.Shift;
        }

        if ((Key & Keys.Alt) == Keys.Alt)
        {
            modifers |= ModifierKeys.Alt;
            key      ^= Keys.Alt;
        }

        if (key is Keys.ShiftKey or Keys.ControlKey or Keys.Menu) key = Keys.None;

        return (key, modifers);
    }

    public event EventHandler? Pressed;

    private bool _Disposed;

    // ReSharper disable once InconsistentNaming
    private const int WM_HOTKEY = 0x0312;

    public IntPtr Handle { get; }

    private readonly ushort _Id;

    public ModifierKeys Modifiers { get; }

    public Keys Key { get; }

    public GlobalHotKey(IntPtr Handle, Keys Key, ModifierKeys Modifiers = ModifierKeys.None)
    {
        if (Key == Keys.None) throw new ArgumentException(nameof(Key));

        var atom_name = Thread.CurrentThread.ManagedThreadId.ToString("X8") + GetType().FullName;

        this.Handle    = Handle;
        _Id            = GlobalAddAtom(atom_name);
        this.Modifiers = Modifiers;
        this.Key       = Key;

        Initialize();

        ComponentDispatcher.ThreadPreprocessMessage += OnThreadFilterMessage;
    }

    private void OnThreadFilterMessage(ref MSG Msg, ref bool Handled)
    {
        if (Msg.message == WM_HOTKEY && Msg.hwnd == Handle && Msg.wParam == (IntPtr)_Id)
        {
            Pressed?.Invoke(this, EventArgs.Empty);
            Handled = true;
        }
    }


    private void Initialize()
    {
        var is_registerd = RegisterHotKey(Handle, _Id, Modifiers, Key);

        if (is_registerd) return;

        UnregisterHotKey(IntPtr.Zero, _Id);

        is_registerd = RegisterHotKey(Handle, _Id, Modifiers, Key);

        // If the operation still failed, it means that the hotkey was already
        // used in another thread or process.
        if (is_registerd) return;

        throw new Win32Exception();
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_Disposed) return;

        if (disposing)
        {
            ComponentDispatcher.ThreadFilterMessage -= OnThreadFilterMessage;
            UnregisterHotKey(Handle, _Id);
            GlobalDeleteAtom(_Id);
        }

        _Disposed = true;
    }
}