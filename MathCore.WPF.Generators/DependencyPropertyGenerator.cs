using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis.Text;

using ClassSyntax = Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax;
using PropertySyntax = Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax;

namespace MathCore.WPF.Generators;

[Generator]
public class DependencyPropertyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider
            .CreateSyntaxProvider(
                (node, _) => node.IsClassWithAnyProperty(p => p.IsDependency()),
                (c, _) => c.Node as ClassSyntax)
            .Where(c => c is not null)
            .Collect();

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(classes),
            static (compilations, source) => Execute(source.Left, source.Right!, compilations));
    }

    private static void Execute(Compilation Compilation, ImmutableArray<ClassSyntax?> Classes, SourceProductionContext Context)
    {
        if (Classes.IsDefault)
            return;

        foreach (var class_syntax in Classes)
        {
            if (class_syntax is null)
                throw new NullReferenceException();

            if (!class_syntax.IsPartial())
            {
                var class_location = class_syntax.GetLocation();
                var keyword_location = class_syntax.Keyword.GetLocation();
                var error_location = Location.Create(class_syntax.SyntaxTree, TextSpan.FromBounds(class_location.SourceSpan.Start, keyword_location.SourceSpan.End));
                Context.Error(
                    "MCWPFErr001",
                    "Ошибка генерации свойства",
                    "MathCore.WPF",
                    "Класс должен быть partial",
                    error_location);

                continue;
            }

            if (class_syntax.GetStaticModifier() is { } static_modifier)
            {
                Context.Error(
                    "MCWPFErr002",
                    "Ошибка генерации свойства",
                    "MathCore.WPF",
                    "Класс не должен быть статическим",
                    static_modifier.GetLocation());
                continue;
            }

            var model = Compilation.GetSemanticModel(class_syntax.SyntaxTree);

            if (model.GetDeclaredSymbol(class_syntax) is not { IsStatic: false } class_symbol)
                continue;

            var class_name = class_symbol.Name;
            var class_namespace = class_symbol.ContainingNamespace.Name;

            var access_modifiers = class_syntax.EnumAccessModifiers().JoinString(" ");

            var source = new StringBuilder("// Auto-generated code at ")
                .Append("// Autogenerated code at {0:dd.MM.yyyy HH:mm:ss}", DateTime.Now)
                .Nullable()
                .Namespace(class_namespace)
                .AppendLine();

            var is_first = true;
            foreach (var property_symbol in class_symbol.EnumNonStaticProperties())
                if(property_symbol.GetAttributeLike(nameof(DependencyPropertyAttribute)) is { } dp_attribute)
                {
                    if (is_first)
                        is_first = false;
                    else
                        source.AppendLine();

                    var property_name = property_symbol.Name;
                    var property_syntax = class_syntax.Members
                        .OfType<PropertySyntax>()
                        .First(v => v.Identifier.Text == property_name);

                    var comment = property_syntax.GetLeadingTrivia().ToString();

                    var property_type = property_symbol.Type.ToDisplayString();

                    source.AddDependencyProperty(property_name, property_type);
                }

            source.AppendLine("}");

#if DEBUG
            var source_test = source.EnumLines((s, i) => $"{i + 1,3}|{s}").JoinString(Env.NewLine);
#endif

            Context.AddSource($"{class_name}.DependencyProperties.g.cs", source.ToSource());
        }
    }
}