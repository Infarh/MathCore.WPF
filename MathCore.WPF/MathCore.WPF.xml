<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MathCore.WPF</name>
    </assembly>
    <members>
        <member name="M:MathCore.WPF.AnimatedBinding.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="F:MathCore.WPF.Animation.LinearMatrixAnimation.FromProperty">
            <summary>Начальная матрица</summary>
        </member>
        <member name="P:MathCore.WPF.Animation.LinearMatrixAnimation.From">
            <summary>Начальная матрица</summary>
        </member>
        <member name="F:MathCore.WPF.Animation.LinearMatrixAnimation.ToProperty">
            <summary>Конечная матрица</summary>
        </member>
        <member name="P:MathCore.WPF.Animation.LinearMatrixAnimation.To">
            <summary>Конечная матрица</summary>
        </member>
        <member name="F:MathCore.WPF.Animation.LinearMatrixAnimation.EasingFunctionProperty">
            <summary>Функция плавности</summary>
        </member>
        <member name="P:MathCore.WPF.Animation.LinearMatrixAnimation.EasingFunction">
            <summary>Функция плавности</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MathCore.WPF.AutoComplete" -->
        <member name="M:MathCore.WPF.AutoComplete.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.CloseBehavior.CloseWithDialogResultProperty">
            <summary>Признак, при установке которого в истину, окно будет закрыто</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.CloseBehavior.CloseWithDialogResult">
            <summary>Признак, при установке которого в истину, окно будет закрыто</summary>
        </member>
        <member name="M:MathCore.WPF.Behaviors.CloseBehavior.OnDetaching">
            <inheritdoc />
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragBehavior.EnabledProperty">
            <summary></summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.DragBehavior.Enabled">
            <summary></summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragBehavior.dxPropertyKey">
            <summary>Величина смещения по горизонтали</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragBehavior.dxProperty">
            <summary>Величина смещения по горизонтали</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.DragBehavior.dx">
            <summary>Величина смещения по горизонтали</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragBehavior.dyPropertyKey">
            <summary>Величина смещения по вертикали</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragBehavior.dyProperty">
            <summary>Величина смещения по вертикали</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.DragBehavior.dy">
            <summary>Величина смещения по вертикали</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragInCanvasBehavior._Canvas">
            <summary>Ссылка на канву</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragInCanvasBehavior._StartPoint">
            <summary>Запись точной позиции, в которой нажата кнопка</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragInCanvasBehavior._IsDragging">
            <summary>Отслеживание перетаскивания элемента</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragInCanvasBehavior.AllowXProperty">
            <summary>Разрешено перемещение по оси X</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.DragInCanvasBehavior.AllowX">
            <summary>Разрешено перемещение по оси X</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragInCanvasBehavior.AllowYProperty">
            <summary>summary</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.DragInCanvasBehavior.AllowY">
            <summary>Разрешено перетаскивание по оси Y</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DragInCanvasBehavior.EnabledProperty">
            <summary>Перетаскивание активно</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.DragInCanvasBehavior.Enabled">
            <summary>Перетаскивание активно</summary>
        </member>
        <member name="M:MathCore.WPF.Behaviors.DragInCanvasBehavior.OnAttached">
            <summary>Присоединение поведения к объекту</summary>
        </member>
        <member name="M:MathCore.WPF.Behaviors.DragInCanvasBehavior.OnDetaching">
            <summary>Отсоединение поведения от объекта</summary>
        </member>
        <member name="M:MathCore.WPF.Behaviors.DragInCanvasBehavior.OnMouseLeftButtonDown(System.Object,System.Windows.Input.MouseButtonEventArgs)">
            <summary>При нажатии левой кнопки мыши</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:MathCore.WPF.Behaviors.DragInCanvasBehavior.OnMouseMove(System.Object,System.Windows.Input.MouseEventArgs)">
            <summary>При перемещении мыши</summary>
        </member>
        <member name="M:MathCore.WPF.Behaviors.DragInCanvasBehavior.OnMouseLeftButtonUp(System.Object,System.Windows.Input.MouseButtonEventArgs)">
            <summary>При отпускании левой кнопки мыши</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DropData.DropDataCommandProperty">
            <summary>Команда, вызываемая в момент получения данных</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.DropData.DropDataCommand">
            <summary>Команда, вызываемая в момент получения данных</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DropData.DataFormatProperty">
            <summary>Предпочитаемый формат данных</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.DropData.DataFormat">
            <summary>Предпочитаемый формат данных</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DropData.DataFormatAutoConversationProperty">
            <summary>Автоматически преобразовывать данные</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.DropData.DataFormatAutoConversation">
            <summary>Автоматически преобразовывать данные</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.DropData.DataTypeProperty">
            <summary>Предпочитаемый тип данных</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.DropData.DataType">
            <summary>Предпочитаемый тип данных</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.MouseControlBehavior.MousePositionProperty">
            <summary>Положение указателя мыши</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.MouseControlBehavior.MousePosition">
            <summary>Положение указателя мыши</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.MouseControlBehavior.MousePositionRelativeProperty">
            <summary>Относительное положение указателя мыши</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.MouseControlBehavior.MousePositionRelative">
            <summary>Относительное положение указателя мыши</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.MouseControlBehavior.ElementSizeProperty">
            <summary>Размер элемента управления</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.MouseControlBehavior.ElementSize">
            <summary>Размер элемента управления</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.MouseControlBehavior.IsLeftMouseDownProperty">
            <summary>Нажатие левой клавиши мыши</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.MouseControlBehavior.IsLeftMouseDown">
            <summary>Нажатие левой клавиши мыши</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.MouseControlBehavior.LeftMouseClickProperty">
            <summary>Команда, выполняемая при щелчке мышью</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.MouseControlBehavior.LeftMouseClick">
            <summary>Команда, выполняемая при щелчке мышью</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.Resize.TopResizing">
            <summary>Изменение размера сверху</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.Resize.BottomResizingProperty">
            <summary>Изменение размера снизу</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.Resize.BottomResizing">
            <summary>Изменение размера снизу</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.Resize.LeftResizingProperty">
            <summary>Изменение размера слева</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.Resize.LeftResizing">
            <summary>Изменение размера слева</summary>
        </member>
        <member name="F:MathCore.WPF.Behaviors.Resize.RightResizingProperty">
            <summary>Изменение размера справа</summary>
        </member>
        <member name="P:MathCore.WPF.Behaviors.Resize.RightResizing">
            <summary>Изменение размера справа</summary>
        </member>
        <member name="T:MathCore.WPF.Behaviors.ResizeBehavior">
            <summary>A simple Resizing Behavior that makes use of a ResizingAdorner</summary>
        </member>
        <member name="M:MathCore.WPF.Behaviors.ResizeBehavior.ResizeBehaviorParent_Loaded(System.Object,System.Windows.RoutedEventArgs)">
            <summary>Create the AdornerLayer when Parent for current Element loads</summary>
        </member>
        <member name="M:MathCore.WPF.Behaviors.ResizeBehavior.AttachedElement_MouseEnter(System.Object,System.Windows.Input.MouseEventArgs)">
            <summary>When mouse enters, create a new Resizing Adorner</summary>
        </member>
        <member name="M:MathCore.WPF.Behaviors.ResizeBehavior.ResizingAdorner_MouseLeave(System.Object,System.Windows.Input.MouseEventArgs)">
            <summary>On mouse leave for the Resizing Adorner, remove the Resizing Adorner from the AdornerLayer</summary>
        </member>
        <member name="M:MathCore.WPF.BindingErrorTraceListener.Write(System.String)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.BindingErrorTraceListener.WriteLine(System.String)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.TextCompareType">
            <summary>Способ сравнения строк</summary>
        </member>
        <member name="F:MathCore.WPF.TextCompareType.Contains">
            <summary>Строка должна содержать искомую строку</summary>
        </member>
        <member name="F:MathCore.WPF.TextCompareType.Equals">
            <summary>Строки должны совпадать</summary>
        </member>
        <member name="F:MathCore.WPF.TextCompareType.StartWith">
            <summary>Строка должна начинаться с искомой последовательности</summary>
        </member>
        <member name="F:MathCore.WPF.TextCompareType.EndWith">
            <summary>Строка должна заканчиваться искомой последовательностью</summary>
        </member>
        <member name="T:MathCore.WPF.CollectionViewFilter">
            <summary>Фильтр модели представления коллекций</summary>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.__Collections">
            <summary>Задействованные представления</summary>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.__ProperyNameRegex">
            <summary>Регулярное выражение проверки корректности имени свойства</summary>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.StringComparisonTypeProperty">
            <summary>Метод сравнения строк</summary>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.SetStringComparisonType(System.Windows.DependencyObject,System.StringComparison)">
            <summary>Установка метода сравнения строк для указанной модели представления коллекции</summary>
            <param name="element">Представление, для которой производится установка значения метода сравнения строк</param>
            <param name="value">Устанавливаемый метод сравнения строк</param>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.GetStringComparisonType(System.Windows.DependencyObject)">
            <summary>Получить метод сравнения строк для указанной модели представления коллекции</summary>
            <param name="element">Модель представления коллекции, для которой устанавливается метод сравнения строк</param>
            <returns>Метод сравнения строк</returns>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.TextCompareTypeProperty">
            <summary>Способ сравнения строк</summary>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.SetTextCompareType(System.Windows.DependencyObject,MathCore.WPF.TextCompareType)">
            <summary>Установка способа сравнения строк для модели представления коллекции</summary>
            <param name="element">Модель представления коллекции, для которой устанавливается способ сравнения строк</param>
            <param name="value">Устанавливаемый способ сравнения строк</param>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.GetTextCompareType(System.Windows.DependencyObject)">
            <summary>Получить способ сравнения строк для указанной модели представления коллекции</summary>
            <param name="element">Модель представления коллекции, для которой требуется получить способ сравнения строк</param>
            <returns>Способ сравнения строк</returns>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.PropertyNameProperty">
            <summary>Имя свйоства элемента коллекции, по которому будет производиться фильтрация её элементов</summary>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.SetPropertyName(System.Windows.DependencyObject,System.String)">
            <summary>Установить имя фильтруемого свойства для модели представления коллекции</summary>
            <param name="element">Модель представления коллекции, для которой устанавливается имя фильтруемого свойства её элемента</param>
            <param name="value">Имя свйосвта</param>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.GetPropertyName(System.Windows.DependencyObject)">
            <summary>Получить имя фильтруемого свойства для модели представления коллекции</summary>
            <param name="element">Модель представления коллекции, имя фильтруемого свойство которой требуется получить</param>
            <returns>Имя фильтруемого свойства элемнетов коллекции</returns>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.FilterTextProperty">
            <summary>Текст фильтра</summary>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.SetFilterText(System.Windows.DependencyObject,System.String)">
            <summary>Установить текст фильтра для модели представления коллекции</summary>
            <param name="element">Модель представления колекции, текст фильтра для которой требуется установить</param>
            <param name="value">Устанавливаемый текст фильтра</param>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.GetFilterText(System.Windows.DependencyObject)">
            <summary>Получить значение текста фильтра для модели предатавления коллекции</summary>
            <param name="element">Модель представления коллекции, текст фильтра для которой требуется получить</param>
            <returns>Текст фильтра, установленный для модели предатавления коллекции</returns>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.DelayTimeProperty">
            <summary>Время задержки обновления модели предавления коллекции в миллисеккундах</summary>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.__PropertyChangedEnterTime">
            <summary>Время входа в метод изменения значения свойства фильтра в миллисекундах с начала работы системы</summary>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.PropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>Метод обновления значения присоединённого свойства зависимости для фильтра модели представлния коллекции</summary>
            <param name="D">Модель представления коллекции, для которой изменяется значение свойства</param>
            <param name="E">Информация об изменившемся свойсвте</param>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.Initialize(System.Windows.Data.CollectionViewSource)">
            <summary>Инициализация новой модели представления коллекции</summary>
            <param name="collection_view_source">Модель представления коллекции, которую требуется инициализировать</param>
        </member>
        <member name="T:MathCore.WPF.CollectionViewFilter.TypeProperty">
            <summary>Информация о свойтве для указанного типа</summary>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.TypeProperty._Type">
            <summary>Тип, информацию о свойтве которого требуется сохранить</summary>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.TypeProperty._Property">
            <summary>Имя свйосвта</summary>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.TypeProperty.#ctor(System.Object,System.String)">
            <summary>Инициализация новой структуры с информацией о свойстве типа объекта</summary>
            <param name="item">Объект, имя свойства которого требуется получить</param>
            <param name="property">Имя свйоства объекта</param>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.TypeProperty.GetProperty">
            <summary>Получить делегат метод извлечения значения свойства</summary>
            <returns>Делегат, извлекающий значение свойтва объекта</returns>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.TypeProperty.Equals(MathCore.WPF.CollectionViewFilter.TypeProperty)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.TypeProperty.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.TypeProperty.GetHashCode">
            <inheritdoc />
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilter.__Properties">
            <summary>Словарь свойств типов объектов</summary>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilter.CollectionViewSource_OnFilter(System.Object,System.Windows.Data.FilterEventArgs)">
            <summary>Метод фильтрации элементов модели представления коллекции</summary>
            <param name="sendeer">Модель представления коллекции, фильтрацию объекта которой требуется осуществить</param>
            <param name="e">Информация о объекте, который надо отфильтровать</param>
        </member>
        <member name="M:MathCore.WPF.CollectionViewFiltersCollection.CreateInstanceCore">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.CollectionViewFilterItem.RefreshSource(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>Обновить представление</summary>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilterItem.ValueConverterProperty">
            <summary>Конвертер фильтруемого значения</summary>
        </member>
        <member name="P:MathCore.WPF.CollectionViewFilterItem.ValueConverter">
            <summary>Конвертер фильтруемого значения</summary>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilterItem.FiltredPropertyProperty">
            <summary>Имя фильтруемого свойства объекта</summary>
        </member>
        <member name="P:MathCore.WPF.CollectionViewFilterItem.FiltredProperty">
            <summary>Имя фильтруемого свойства объекта</summary>
        </member>
        <member name="F:MathCore.WPF.CollectionViewFilterItem.EnabledProperty">
            <summary>Активность фильтра</summary>
        </member>
        <member name="P:MathCore.WPF.CollectionViewFilterItem.Enabled">
            <summary>Активность фильтра</summary>
        </member>
        <member name="F:MathCore.WPF.RangeCollectionFilterItem.MinProperty">
            <summary>Свойство минимального фильтруемого значения</summary>
        </member>
        <member name="P:MathCore.WPF.RangeCollectionFilterItem.Min">
            <summary>Свойство минимального фильтруемого значения</summary>
        </member>
        <member name="F:MathCore.WPF.RangeCollectionFilterItem.MinIncludeProperty">
            <summary>Включать нижний предел в выборку</summary>
        </member>
        <member name="P:MathCore.WPF.RangeCollectionFilterItem.MinInclude">
            <summary>Включать нижний предел в выборку</summary>
        </member>
        <member name="F:MathCore.WPF.RangeCollectionFilterItem.MaxProperty">
            <summary>Свойство максимума фильтра</summary>
        </member>
        <member name="P:MathCore.WPF.RangeCollectionFilterItem.Max">
            <summary>Свойство максимума фильтра</summary>
        </member>
        <member name="F:MathCore.WPF.RangeCollectionFilterItem.MaxIncludeProperty">
            <summary>Включать верхний предел в выборку</summary>
        </member>
        <member name="P:MathCore.WPF.RangeCollectionFilterItem.MaxInclude">
            <summary>Включать верхний предел в выборку</summary>
        </member>
        <member name="M:MathCore.WPF.RangeCollectionFilterItem.CreateInstanceCore">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.RangeCollectionFilterItem.OnFilter(System.Object,System.Windows.Data.FilterEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.GroupsCollectionFilterItem.CreateInstanceCore">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.GroupsCollectionFilterItem.OnFilter(System.Object,System.Windows.Data.FilterEventArgs)">
            <inheritdoc />
        </member>
        <member name="F:MathCore.WPF.PropertyFiltersItem.CollectionItemTypeProperty">
            <summary></summary>
        </member>
        <member name="P:MathCore.WPF.PropertyFiltersItem.CollectionItemType">
            <summary></summary>
        </member>
        <member name="M:MathCore.WPF.PropertyFiltersItem.System#Collections#Generic#IEnumerable{MathCore#WPF#PropertyFilterItem}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.PropertyFiltersItem.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.PropertyFiltersItem.Add(MathCore.WPF.PropertyFilterItem)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.PropertyFiltersItem.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.PropertyFiltersItem.System#Collections#Generic#ICollection{MathCore#WPF#PropertyFilterItem}#Contains(MathCore.WPF.PropertyFilterItem)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.PropertyFiltersItem.System#Collections#Generic#ICollection{MathCore#WPF#PropertyFilterItem}#CopyTo(MathCore.WPF.PropertyFilterItem[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.PropertyFiltersItem.Remove(MathCore.WPF.PropertyFilterItem)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.PropertyFiltersItem.System#Collections#Generic#ICollection{MathCore#WPF#PropertyFilterItem}#Count">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.PropertyFiltersItem.System#Collections#Generic#ICollection{MathCore#WPF#PropertyFilterItem}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="E:MathCore.WPF.PropertyFiltersItem.System#Collections#Specialized#INotifyCollectionChanged#CollectionChanged">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.CollectionViewShaper">
             <summary>
             
             </summary>
             <remarks>
             <code>
             // Collection to which the view is bound
                public ObservableCollection People { get; private set; }
                ...
            
             // Default view of the People collection
                ICollectionView view = CollectionViewSource.GetDefaultView(People);
            
                // Show only adults
                view.Filter = o => ((Person) o).Age >= 18;
            
             // Sort by last name and first name
                view.SortDescriptions.Add(new SortDescription("LastName", ListSortDirection.Ascending));
                view.SortDescriptions.Add(new SortDescription("FirstName", ListSortDirection.Ascending));
            
             // Group by country
                view.GroupDescriptions.Add(new PropertyGroupDescription("Country"));
            
             People.Where(p => p.Age >= 18).OrderBy(p => p.LastName).ThenBy(p => p.FirstName).GroupBy(p => p.Country);
             
             from p in People
                    where p.Age >= 18
                    orderby p.LastName, p.FirstName
                    group p by p.Country;
             
             var query = from p in People.ShapeView()
                                where p.Age >= 18
                                orderby p.LastName, p.FirstName
                                group p by p.Country;
             query.Apply()
             
             // Remove the grouping and add a sort criteria
             People.ShapeView()
               .ClearGrouping()
               .OrderBy(p => p.LastName);
               .Apply();
              
             </code>
             </remarks>
        </member>
        <member name="F:MathCore.WPF.ColumnDefinitionCollapsable.VisibleProperty">
            <summary>Видимость</summary>
        </member>
        <member name="P:MathCore.WPF.ColumnDefinitionCollapsable.Visible">
            <summary>Видимость</summary>
        </member>
        <member name="T:MathCore.WPF.Commands.AsyncTaskCommand`1">
            <summary>Асинхронная команда</summary>
            <example>
            Url = "http://www.example.com/";
            CountUrlBytesCommand = new AsyncCommand(async () => { ByteCount = await MyService.DownloadAndCountBytesAsync(Url); });
            CountUrlBytesCommand = new AsyncCommand(MyService.DownloadAndCountBytesAsync(Url));
            </example>
        </member>
        <member name="E:MathCore.WPF.Commands.Command.CanExecuteChanged">
            <summary>Событие возникает при изменении возможности исполнения команды</summary>
        </member>
        <member name="P:MathCore.WPF.Commands.Command.IsCanExecute">
            <summary>Признак возможности исполнения</summary>
        </member>
        <member name="M:MathCore.WPF.Commands.Command.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Commands.CommandBehavior">
            <summary>Defines the attached properties to create a CommandBehaviorBinding</summary>
        </member>
        <member name="F:MathCore.WPF.Commands.CommandBehavior._BehaviorProperty">
            <summary>Behavior Attached Dependency Property</summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.Getf_Behavior(System.Windows.DependencyObject)">
            <summary>Gets the Behavior property</summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.Setf_Behavior(System.Windows.DependencyObject,MathCore.WPF.Commands.CommandBehaviorBinding)">
            <summary>
            Sets the Behavior property.  
            </summary>
        </member>
        <member name="F:MathCore.WPF.Commands.CommandBehavior.CommandProperty">
            <summary>Command Attached Dependency Property</summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.GetCommand(System.Windows.DependencyObject)">
            <summary>
            Gets the Command property.  
            </summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.SetCommand(System.Windows.DependencyObject,System.Windows.Input.ICommand)">
            <summary>
            Sets the Command property. 
            </summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.OnCommandChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>Handles changes to the Command property</summary>
        </member>
        <member name="F:MathCore.WPF.Commands.CommandBehavior.CommandParameterProperty">
            <summary>CommandParameter Attached Dependency Property</summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.GetCommandParameter(System.Windows.DependencyObject)">
            <summary>
            Gets the CommandParameter property.  
            </summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.SetCommandParameter(System.Windows.DependencyObject,System.Object)">
            <summary>
            Sets the CommandParameter property. 
            </summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.OnCommandParameterChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles changes to the CommandParameter property.
            </summary>
        </member>
        <member name="F:MathCore.WPF.Commands.CommandBehavior.EventProperty">
            <summary>Event Attached Dependency Property</summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.GetEvent(System.Windows.DependencyObject)">
            <summary>
            Gets the Event property.  This dependency property 
            indicates ....
            </summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.SetEvent(System.Windows.DependencyObject,System.String)">
            <summary>
            Sets the Event property.  This dependency property 
            indicates ....
            </summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehavior.OnEventChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>Handles changes to the Event property</summary>
        </member>
        <member name="T:MathCore.WPF.Commands.CommandBehaviorBinding">
            <summary>Defines the command behavior binding</summary>
        </member>
        <member name="P:MathCore.WPF.Commands.CommandBehaviorBinding.Owner">
            <summary>
            Get the owner of the CommandBinding ex: a Button
            This property can only be set from the BindEvent Method
            </summary>
        </member>
        <member name="P:MathCore.WPF.Commands.CommandBehaviorBinding.Command">
            <summary>
            The command to execute when the specified event is raised
            </summary>
        </member>
        <member name="P:MathCore.WPF.Commands.CommandBehaviorBinding.CommandParameter">
            <summary>
            Gets or sets a CommandParameter
            </summary>
        </member>
        <member name="P:MathCore.WPF.Commands.CommandBehaviorBinding.EventName">
            <summary>
            The event name to hook up to
            This property can only be set from the BindEvent Method
            </summary>
        </member>
        <member name="P:MathCore.WPF.Commands.CommandBehaviorBinding.Event">
            <summary>
            The event info of the event
            </summary>
        </member>
        <member name="P:MathCore.WPF.Commands.CommandBehaviorBinding.EventHandler">
            <summary>
            Gets the EventHandler for the binding with the event
            </summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehaviorBinding.ExecuteCommand">
            <summary>
            Executes the command
            </summary>
        </member>
        <member name="M:MathCore.WPF.Commands.CommandBehaviorBinding.Dispose">
            <summary>
            Unregisters the EventHandler from the Event
            </summary>
        </member>
        <member name="T:MathCore.WPF.Commands.EventHandlerGenerator">
            <summary>Generates delegates according to the specified signature on runtime</summary>
        </member>
        <member name="M:MathCore.WPF.Commands.EventHandlerGenerator.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Object)">
            <summary>
            Generates a delegate with a matching signature of the supplied eventHandlerType
            This method only supports Events that have a delegate of type void
            </summary>
            <param name="EventHandlerType"></param>
            <param name="MethodToInvoke">The method to invoke</param>
            <param name="MethodInvoker">The object where the method resides</param>
            <returns>Returns a delegate with the same signature as eventHandlerType that calls the methodToInvoke inside</returns>
            <exception cref="T:System.ApplicationException">Delegate has a return type. This only supprts event handlers that are void</exception>
        </member>
        <member name="M:MathCore.WPF.Commands.EventCommand.Execute(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.EventCommand.CanExecute(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Commands.LambdaCommand">
            <summary>
            Лямбда-команда
            Позволяет быстро указывать методы для выполнения основного тела команды и определения возможности выполнения
            </summary>
        </member>
        <member name="E:MathCore.WPF.Commands.LambdaCommand.Cancelled">
            <summary>Возникает, когда команда отменена</summary>
        </member>
        <member name="F:MathCore.WPF.Commands.LambdaCommand._ExecuteAction">
            <summary>Делегат основного тела команды</summary>
        </member>
        <member name="F:MathCore.WPF.Commands.LambdaCommand._CanExecute">
            <summary>Функция определения возможности исполнения команды</summary>
        </member>
        <member name="P:MathCore.WPF.Commands.LambdaCommand.CanExecuteDelegate">
            <summary>Функция определения возможности исполнения команды</summary>
        </member>
        <member name="M:MathCore.WPF.Commands.LambdaCommand.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.LambdaCommand.Execute(System.Object)">
            <summary>Выполнение команды</summary>
            <param name="parameter">Параметр процесса выполнения команды</param>
            <exception cref="T:System.InvalidOperationException">Метод выполнения команды не определён</exception>
        </member>
        <member name="M:MathCore.WPF.Commands.LambdaCommand.CanExecute(System.Object)">
            <summary>Проверка возможности выполнения команды</summary>
            <param name="parameter">Параметр процесса выполнения команды</param>
            <returns>Истина, если команда может быть выполнена</returns>
        </member>
        <member name="M:MathCore.WPF.Commands.LambdaCommand.CanExecuteCheck">
            <summary>Проверка возможности выполнения команды</summary>
        </member>
        <member name="T:MathCore.WPF.Commands.LambdaCommand`1">
            <summary>
            Типизированная лямбда-команда
            Позволяет быстро указывать методы для выполнения основного тела команды и определения возможности выполнения
            </summary>
        </member>
        <member name="E:MathCore.WPF.Commands.LambdaCommand`1.Cancelled">
            <summary>Возникает, когда команда отменена</summary>
        </member>
        <member name="F:MathCore.WPF.Commands.LambdaCommand`1._ExecuteAction">
            <summary>Делегат основного тела команды</summary>
        </member>
        <member name="F:MathCore.WPF.Commands.LambdaCommand`1._CanExecute">
            <summary>Функция определения возможности исполнения команды</summary>
        </member>
        <member name="P:MathCore.WPF.Commands.LambdaCommand`1.CanExecuteDelegate">
            <summary>Функция определения возможности исполнения команды</summary>
        </member>
        <member name="M:MathCore.WPF.Commands.LambdaCommand`1.#ctor">
            <summary>
            Скрытый конструктор для потомков класса, желающих вручную установить значения действия выполнения команды <see cref="F:MathCore.WPF.Commands.LambdaCommand`1._ExecuteAction"/> и функции проверки выполнимости команды <see cref="F:MathCore.WPF.Commands.LambdaCommand`1._CanExecute"/>
            Перед началом использования команды поля <see cref="F:MathCore.WPF.Commands.LambdaCommand`1._ExecuteAction"/> и <see cref="F:MathCore.WPF.Commands.LambdaCommand`1._CanExecute"/> должны быть != <see langword="null"/>
            </summary>
        </member>
        <member name="M:MathCore.WPF.Commands.MultyCommand.CanExecute(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.MultyCommand.Execute(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.MultyCommand.AddChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.MultyCommand.AddText(System.String)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.OpenDirectoryCommand.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.OpenWindowCommand.CanExecute(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.OpenWindowCommand.Execute(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.RenderImageToClipboardCommand.#ctor">
            <inheritdoc />
        </member>
        <member name="F:MathCore.WPF.Commands.ShowMessageCommand._Result">
            <summary>Результат выполнения команды</summary>
        </member>
        <member name="P:MathCore.WPF.Commands.ShowMessageCommand.Result">
            <summary>Результат выполнения команды</summary>
        </member>
        <member name="E:MathCore.WPF.Commands.UpdateBindingCommand.CanExecuteChanged">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.UpdateBindingCommand.Execute(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.UpdateBindingCommand.CanExecute(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Commands.UpdateBindingCommand.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Abs.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Abs.ConvertBack(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.Addition">
            <summary>Преобразователь сложения значения с вещественным числом</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.AdditionMulty.Convert(System.Double[])">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.AggregateArray.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.AndConverter.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.ArrayElement.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Average.To(System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.Combyne">
            <summary>Преобразователь значений, комбинирующий действие нескольких вложенных преобразователей</summary>
        </member>
        <member name="P:MathCore.WPF.Converters.Combyne.First">
            <summary>Первый применяемый вложенный преобразователь</summary>
        </member>
        <member name="P:MathCore.WPF.Converters.Combyne.Then">
            <summary>Второй применяемый вложенный преобразователь</summary>
        </member>
        <member name="P:MathCore.WPF.Converters.Combyne.Other">
            <summary>Массив остальных вложенных преобразователей</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.Combyne.#ctor">
            <summary>Инициализация нового комбинированного преобразователя значений</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.Combyne.#ctor(System.Windows.Data.IValueConverter,System.Windows.Data.IValueConverter)">
            <summary>Инициализация нового комбинированного преобразователя значений</summary>
            <param name="first">Первый вложенный преобразователь значения</param>
            <param name="then">Второй вложенный преобразователь значения</param>
        </member>
        <member name="M:MathCore.WPF.Converters.Combyne.#ctor(System.Windows.Data.IValueConverter,System.Windows.Data.IValueConverter,System.Windows.Data.IValueConverter[])">
            <summary>Инициализация нового комбинированного преобразователя значений</summary>
            <param name="first">Первый вложенный преобразователь значения</param>
            <param name="then">Второй вложенный преобразователь значения</param>
            <param name="other">Остальные вложенные преобразователя зничений</param>
        </member>
        <member name="M:MathCore.WPF.Converters.Combyne.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Combyne.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.Converters.CompositeConverter.Converters">
            <summary>Коллекция конвертеров</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.CompositeConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.CompositeConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.CSplineInterp.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.CSplineInterp.ConvertBack(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.DataLengthString.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.dBConverter.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.dBConverter.ConvertBack(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.Deviation">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.Divade">
            <summary>Преобразователь деления значения на вещественное число</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.DoubleToBoolConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.DoubleToBoolConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.DoubleValueConverter">
            <summary>Математический конвертер одной переменной</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.DoubleValueConverter.ConvertToDouble(System.Object)">
            <summary>Преобразование объекта в вещественный тип данных</summary>
            <param name="obj">Преобразуемое значение</param>
            <returns>Значение вещественного типа, если преобразование прошло успешно, и NaN в противном случае</returns>
        </member>
        <member name="M:MathCore.WPF.Converters.DoubleValueConverter.TryConvertToDouble(System.Object,System.Double@)">
            <summary>Попытка преобразования объекта в вещественный тип данных</summary>
            <param name="obj">Преобразуемый объект</param>
            <param name="value">Выходное значение вещественного типа данных в случае успешного преобразования и NaN в противном случае</param>
            <returns>Результат успешности преобразования</returns>
        </member>
        <member name="M:MathCore.WPF.Converters.DoubleValueConverter.Convert(System.Double,System.Nullable{System.Double})">
            <summary>Преобразование значения</summary>
            <param name="v">Преобразуемое значение</param>
            <param name="p">Возможный параметр преобразования</param>
            <returns>Преобразованное значение</returns>
        </member>
        <member name="M:MathCore.WPF.Converters.DoubleValueConverter.ConvertBack(System.Double,System.Nullable{System.Double})">
            <summary>Обратное преобразование значения</summary>
            <param name="v">Преобразованное значение</param>
            <param name="p">Возможный параметр преобразования</param>
            <returns>Исходное значение</returns>
            <exception cref="T:System.NotSupportedException">Генерируется при отсутствии переопределения в классах наследниках</exception>
        </member>
        <member name="M:MathCore.WPF.Converters.DoubleValueConverter.CheckParameters(System.Object,System.Object,System.Double@,System.Nullable{System.Double}@)">
            <summary>Проверка входных параметров</summary>
            <param name="v">Входное значение</param>
            <param name="p">Входной параметр</param>
            <param name="value">Входное значение, приведённое к вещественному типу данных</param>
            <param name="parameter">Входной параметр, приведённый к вещественному типу данных</param>
        </member>
        <member name="M:MathCore.WPF.Converters.DoubleValueConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.DoubleValueConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.ExConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.ExConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.InIntervalValue.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.InRange.Convert(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.IO.FilePathToFileNameConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.IO.StringToFileInfo.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.IO.StringToFileInfo.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.IsNaN.Convert(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.IsNegative.Convert(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.IsPositive.Convert(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Lambda`2.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Lambda`2.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.Linear">
            <summary>Линейный конвертер вещественных величин по формуле result = K*value + B</summary>
        </member>
        <member name="P:MathCore.WPF.Converters.Linear.K">
            <summary>Линейный множитель (тангенс угла наклона)</summary>
        </member>
        <member name="P:MathCore.WPF.Converters.Linear.B">
            <summary>Аддитивное смещение</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.Linear.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Linear.ConvertBack(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Mod.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.MultiDoubleValueValueConverter.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.MultiDoubleValueValueConverter.ConvertBack(System.Object,System.Type[],System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.MultiValueValueConverter">
            <summary>Конвертер величин</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.MultiValueValueConverter.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.MultiValueValueConverter.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>Преобразование значений</summary>
            <param name="vv">Массив преобразуемых значений</param>
            <param name="t">Требуемый тип значения</param>
            <param name="p">Параметр преобразования</param>
            <param name="c">Сведения о культуре</param>
            <returns>Преобразованное значение</returns>
        </member>
        <member name="M:MathCore.WPF.Converters.MultiValueValueConverter.ConvertBack(System.Object,System.Type[],System.Object,System.Globalization.CultureInfo)">
            <summary>Обратное преобразование значения</summary>
            <param name="v">Значение, для которого требуется выполнить обратное преобразование</param>
            <param name="tt">Массив требуемых типов данных значений</param>
            <param name="p">Параметр преобразования</param>
            <param name="c">Сведения о культуре</param>
            <returns>Исходные значения</returns>
            <exception cref="T:System.NotSupportedException">Генерируется при отсутствии переопределения в классах наследниках</exception>
        </member>
        <member name="M:MathCore.WPF.Converters.MultiValueValueConverter.System#Windows#Data#IMultiValueConverter#Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.MultiValueValueConverter.System#Windows#Data#IMultiValueConverter#ConvertBack(System.Object,System.Type[],System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.Multipy">
            <summary>Преобразователь умножения значения на вещественное число</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.NANtoVisibility.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Not.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Not.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Null2Visibility.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.OrConverter.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.OutRange.Convert(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Range.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Reflection.AssemblyConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Reflection.GetTypeAssembly.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Round.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Round.ConvertBack(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.RoundAdaptive.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.RoundAdaptive.ConvertBack(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Sign.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Sign.ConvertBack(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.SignValueConverter.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.SimpleDoubleValueConverter">
            <summary>Простой математический конвертер для бинарных операций с констентой (либо с параметром)</summary>
        </member>
        <member name="T:MathCore.WPF.Converters.SimpleDoubleValueConverter.Conversion">
            <summary>Метод преобразования значения</summary>
            <param name="value">Преобразуемое значение</param>
            <param name="parameter">Параметр преобразования</param>
            <returns>Преобразованное значение</returns>
        </member>
        <member name="F:MathCore.WPF.Converters.SimpleDoubleValueConverter._To">
            <summary>Метд прямого преобразования</summary>
        </member>
        <member name="F:MathCore.WPF.Converters.SimpleDoubleValueConverter._From">
            <summary>Метод обратного преобразования</summary>
        </member>
        <member name="P:MathCore.WPF.Converters.SimpleDoubleValueConverter.Parameter">
            <summary>Параметр преобразования</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.SimpleDoubleValueConverter.To(System.Double,System.Double)">
            <summary>Прямое преобразование значения</summary>
            <param name="v">Преобразуемое значение</param>
            <param name="p">Возможный параметр преобразования. В случае отсутствия берётся значение параметра объекта</param>
            <returns>Преобразованное значение</returns>
        </member>
        <member name="M:MathCore.WPF.Converters.SimpleDoubleValueConverter.From(System.Double,System.Double)">
            <summary>Обратное преобразование значения</summary>
            <param name="v">Преобразованное значение</param>
            <param name="p">Возможный параметр преобразования. В случае отсутствия берётся значение параметра объекта</param>
            <returns>Исходное значение</returns>
        </member>
        <member name="M:MathCore.WPF.Converters.SimpleDoubleValueConverter.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.SimpleDoubleValueConverter.ConvertBack(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.SingleValue.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.Substraction">
            <summary>Преобразователь вычитания вещественного числа из значения</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.SubstractionMulty.Convert(System.Double[])">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.TimeDifferential">
            <summary>Конвертер дифференцирования значения по времени</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.TimeDifferential.To(System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.ToStringConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Trunc.Convert(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.Trunc.ConvertBack(System.Double,System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Converters.ValueConverter">
            <summary>Конвертер величин</summary>
        </member>
        <member name="M:MathCore.WPF.Converters.ValueConverter.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.ValueConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>Преобразование значения</summary>
            <param name="v">Преобразуемое значение</param>
            <param name="t">Требуемый тип значения</param>
            <param name="p">Параметр преобразования</param>
            <param name="c">Сведения о культуре</param>
            <returns>Преобразованное значение</returns>
        </member>
        <member name="M:MathCore.WPF.Converters.ValueConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>Обратное преобразование значения</summary>
            <param name="v">Значение, для которого требуется выполнить обратное преобразование</param>
            <param name="t">Требуемый тип данных значения</param>
            <param name="p">Параметр преобразования</param>
            <param name="c">Сведения о культуре</param>
            <returns>Исходное значение</returns>
            <exception cref="T:System.NotSupportedException">Генерируется при отсутствии переопределения в классах наследниках</exception>
        </member>
        <member name="M:MathCore.WPF.Converters.ValueConverter.System#Windows#Data#IValueConverter#Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Converters.ValueConverter.System#Windows#Data#IValueConverter#ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.CustomSynchronizationContext">
            <summary></summary>
            <example>
            static void Main(string[] args)
            {
               var syncContext = new CustomSynchronizationContext();
               try
               {
                  syncContext.Send(o => { throw new Exception("TestException"); }, null);
               } catch(Exception ex)
               {
                   Console.WriteLine(ex.Message);
               }
            }
            -----
            static void Main(string[] args)
            {
                var syncContext = new CustomSynchronizationContext();
                syncContext.Post(TestAsyncMethod, null);
            }
            
            async static void TestAsyncMethod(object obj)
            {
                Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
                await Task.Factory.StartNew(() => Console.WriteLine(Thread.CurrentThread.ManagedThreadId));
                Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
            }
            </example>
        </member>
        <member name="F:MathCore.WPF.Dialogs.ShowWindow.MaxWidthProperty">
            <summary>Максимальная ширина окна</summary>
        </member>
        <member name="P:MathCore.WPF.Dialogs.ShowWindow.MaxWidth">
            <summary>Максимальная ширина окна</summary>
        </member>
        <member name="F:MathCore.WPF.Dialogs.ShowWindow.MaxHeightProperty">
            <summary>Максимальная высота окна</summary>
        </member>
        <member name="P:MathCore.WPF.Dialogs.ShowWindow.MaxHeight">
            <summary>Максимальная высота окна</summary>
        </member>
        <member name="F:MathCore.WPF.Dialogs.ShowWindow.IconProperty">
            <summary>Иконка окна</summary>
        </member>
        <member name="P:MathCore.WPF.Dialogs.ShowWindow.Icon">
            <summary>Иконка окна</summary>
        </member>
        <member name="F:MathCore.WPF.Dialogs.ShowWindow.TopmostProperty">
            <summary>Окно является окном верхнего уровня</summary>
        </member>
        <member name="P:MathCore.WPF.Dialogs.ShowWindow.Topmost">
            <summary>Окно является окном верхнего уровня</summary>
        </member>
        <member name="F:MathCore.WPF.Dialogs.ShowWindow.OwnerProperty">
            <summary>Окно - владелец</summary>
        </member>
        <member name="P:MathCore.WPF.Dialogs.ShowWindow.Owner">
            <summary>Окно - владелец</summary>
        </member>
        <member name="F:MathCore.WPF.Dialogs.ShowWindow.WindowStateProperty">
            <summary>Состояние окна</summary>
        </member>
        <member name="P:MathCore.WPF.Dialogs.ShowWindow.WindowState">
            <summary>Состояние окна</summary>
        </member>
        <member name="F:MathCore.WPF.Dialogs.ShowWindow.StartupLocationProperty">
            <summary>Начальное положение окна</summary>
        </member>
        <member name="P:MathCore.WPF.Dialogs.ShowWindow.StartupLocation">
            <summary>Начальное положение окна</summary>
        </member>
        <member name="F:MathCore.WPF.Dialogs.ShowWindow.SizeToContentProperty">
            <summary>Принцип автоматического изменения размеров окна</summary>
        </member>
        <member name="P:MathCore.WPF.Dialogs.ShowWindow.SizeToContent">
            <summary>Принцип автоматического изменения размеров окна</summary>
        </member>
        <member name="E:MathCore.WPF.EventsTrigger.TriggersPool.CollectionChanged">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.EventsTrigger.Subscribe(System.IObserver{System.Boolean})">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Rotate">
            <summary>Трансформация поворота</summary>
        </member>
        <member name="P:MathCore.WPF.Rotate.Angle">
            <summary>Угол</summary>
        </member>
        <member name="P:MathCore.WPF.Rotate.X">
            <summary>X-центра</summary>
        </member>
        <member name="P:MathCore.WPF.Rotate.Y">
            <summary>Y-центра</summary>
        </member>
        <member name="M:MathCore.WPF.Rotate.#ctor">
            <summary>Трансформация поворота</summary>
        </member>
        <member name="M:MathCore.WPF.Rotate.#ctor(System.Double)">
            <summary>Трансформация поворота</summary>
            <param name="angle">Угол</param>
        </member>
        <member name="M:MathCore.WPF.Rotate.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Scale">
            <summary>Трансформация масштабирования</summary>
        </member>
        <member name="P:MathCore.WPF.Scale.X">
            <summary>Масштаб по X</summary>
        </member>
        <member name="P:MathCore.WPF.Scale.Y">
            <summary>Масштаб по Y</summary>
        </member>
        <member name="P:MathCore.WPF.Scale.X0">
            <summary>X-центра</summary>
        </member>
        <member name="P:MathCore.WPF.Scale.Y0">
            <summary>Y-центра</summary>
        </member>
        <member name="M:MathCore.WPF.Scale.#ctor">
            <summary>Трансформация масштабирования</summary>
        </member>
        <member name="M:MathCore.WPF.Scale.#ctor(System.Double,System.Double)">
            <summary>Трансформация масштабирования</summary>
            <param name="x">Масштаб по X</param>
            <param name="y">Масштаб по Y</param>
        </member>
        <member name="M:MathCore.WPF.Scale.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Shadow">
            <summary>Эффект тени</summary>
        </member>
        <member name="P:MathCore.WPF.Shadow.Depth">
            <summary>Глубина тени</summary>
        </member>
        <member name="P:MathCore.WPF.Shadow.Bias">
            <summary>Алгоритм рендринга</summary>
        </member>
        <member name="P:MathCore.WPF.Shadow.Opacity">
            <summary>Прозрачность</summary>
        </member>
        <member name="P:MathCore.WPF.Shadow.Direction">
            <summary>Направление</summary>
        </member>
        <member name="P:MathCore.WPF.Shadow.Color">
            <summary>Цвет</summary>
        </member>
        <member name="P:MathCore.WPF.Shadow.Blur">
            <summary>Размытие</summary>
        </member>
        <member name="M:MathCore.WPF.Shadow.#ctor">
            <summary>Эффект тени</summary>
        </member>
        <member name="M:MathCore.WPF.Shadow.#ctor(System.Double)">
            <summary>Эффект тени</summary>
            <param name="depth">Глубина</param>
        </member>
        <member name="M:MathCore.WPF.Shadow.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Translate">
            <summary>Трансформация смещения</summary>
        </member>
        <member name="P:MathCore.WPF.Translate.X">
            <summary>Смещение по X</summary>
        </member>
        <member name="P:MathCore.WPF.Translate.Y">
            <summary>Смещение по Y</summary>
        </member>
        <member name="M:MathCore.WPF.Translate.#ctor">
            <summary>Трансформация смещения</summary>
        </member>
        <member name="M:MathCore.WPF.Translate.#ctor(System.Double,System.Double)">
            <summary>Трансформация смещения</summary>
            <param name="x">Смещение по X</param>
            <param name="y">Смещение по Y</param>
        </member>
        <member name="M:MathCore.WPF.Translate.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.VisualCache">
            <summary>Кеширование изображения</summary>
        </member>
        <member name="P:MathCore.WPF.VisualCache.Scale">
            <summary>Маштаб рендринга изображения</summary>
        </member>
        <member name="P:MathCore.WPF.VisualCache.RealPixels">
            <summary>Привязка к пикселям</summary>
        </member>
        <member name="M:MathCore.WPF.VisualCache.#ctor">
            <summary>Кеширование изображения</summary>
        </member>
        <member name="M:MathCore.WPF.VisualCache.#ctor(System.Double)">
            <summary>Кеширование изображения</summary>
            <param name="scale"></param>
        </member>
        <member name="M:MathCore.WPF.VisualCache.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Extensions.BindingConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Extensions.BindingConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Extensions.BindingTypeDescriptionProvider.GetTypeDescriptor(System.Type,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Extensions.BindingCustomTypeDescriptor.GetProperties">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Extensions.BindingCustomTypeDescriptor.GetProperties(System.Attribute[])">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Extensions.TypeExtensions.GetTypeConverter(System.Type)">
            <summary>Получить конвертер значений для указанного типа данных</summary>
            <param name="type">Тип, для которого требуется получить конвертер</param>
            <returns>Конвертер указанного типа данных</returns>
        </member>
        <member name="M:MathCore.WPF.Extensions.TypeExtensions.GetType(System.String)">
            <summary>Получить тип по его имени из всех загруженных сборок</summary>
            <param name="TypeName">Имя типа</param>
            <returns>Тип</returns>
        </member>
        <member name="M:MathCore.WPF.Extensions.TypeExtensions.GetCustomAttributes``1(System.Type)">
            <summary>Получить все атрибуты типа указанного типа</summary>
            <typeparam name="TAttribute">Тип требуемых атрибутов</typeparam>
            <param name="T">Тип, атрибуты которого требуется получить</param>
            <returns>Массив атрибутов типа указанного типа</returns>
        </member>
        <member name="T:MathCore.WPF.Field">
            <summary>Поле данных</summary>
        </member>
        <member name="F:MathCore.WPF.Field.ValueProperty">
            <summary>Свойство зависимости, зранящее значение поля</summary>
        </member>
        <member name="P:MathCore.WPF.Field.Value">
            <summary>Свойство зависимости, зранящее значение поля</summary>
        </member>
        <member name="M:MathCore.WPF.Field.CreateInstanceCore">
            <inheritdoc />
        </member>
        <member name="F:MathCore.WPF.FieldValue.ValueProperty">
            <summary>Значение поля</summary>
        </member>
        <member name="P:MathCore.WPF.FieldValue.Value">
            <summary>Значение поля</summary>
        </member>
        <member name="T:MathCore.WPF.FileSystem">
            <summary>Объект слежения за дисками, подключёнными к системе</summary>
        </member>
        <member name="F:MathCore.WPF.FileSystem.__FileSystem">
            <summary>Поле паттерна синглтон</summary>
        </member>
        <member name="P:MathCore.WPF.FileSystem.Watcher">
            <summary>Объект слежения за дисками, подключёнными к системе</summary>
        </member>
        <member name="F:MathCore.WPF.FileSystem._WindowHandle">
            <summary>Дескриптор окна, получающего сообщения от системы о смене состояния оборудования</summary>
        </member>
        <member name="F:MathCore.WPF.FileSystem._Drives">
            <summary>Кеш массива дисков системы</summary>
        </member>
        <member name="P:MathCore.WPF.FileSystem.Drives">
            <summary>Диски системы</summary>
        </member>
        <member name="M:MathCore.WPF.FileSystem.IsDriveListEquals(System.IO.DriveInfo[],System.IO.DriveInfo[])">
            <summary>Проверка списков дисков на идентичность</summary>
            <param name="Old">Старый список дисков</param>
            <param name="New">Новый список дисков</param>
            <returns>Истина, если списки идентичны</returns>
        </member>
        <member name="M:MathCore.WPF.FileSystem.#ctor">
            <summary>Инициализация нового наблюдателя за дисками системы</summary>
        </member>
        <member name="M:MathCore.WPF.FileSystem.OnWindowLoaded(System.Object,System.EventArgs)">
            <summary>обработчик события, возникающего в момент завершения загрузки окна, в котором подключается обработчик системных сообщений</summary>
            <param name="Sender">Окно-источник события</param>
            <param name="E">Аргумент события (игнорируется)</param>
        </member>
        <member name="F:MathCore.WPF.FileSystem.WM_DEVICECHANGE">
            <summary>Сообщение Windows, приходящее окну в момент смены конфигурации системы по поборудованию</summary>
        </member>
        <member name="M:MathCore.WPF.FileSystem.WndProc(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.Boolean@)">
            <summary>Обработчик сообщений системы, приходящих окну приложения</summary>
            <param name="hwnd">Дескриптор окна, получившего сообщение</param>
            <param name="msg">Номер сообщения</param>
            <param name="wParam">Параметры сообщения</param>
            <param name="lParam">Параметры сообщения</param>
            <param name="handled">Признак того, что сообщение было обработано в оконной функции</param>
            <returns>Результат оброботки сообщения - должен быть <see cref="F:System.IntPtr.Zero"/></returns>
        </member>
        <member name="M:MathCore.WPF.FileSystem.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.DirectoryViewModel.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Filter">
            <summary>
            Provides a search/filter for items bind to an ItemsControl.
            To use this control, simply place an ItemsControl object as the content
            </summary>
        </member>
        <member name="M:MathCore.WPF.Int64Array.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Int32Array.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Int16Array.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="F:MathCore.WPF.LanguageManager.InputCultureProperty">
            <summary></summary>
        </member>
        <member name="P:MathCore.WPF.LanguageManager.InputCulture">
            <summary></summary>
        </member>
        <member name="M:MathCore.WPF.ElementController`1.SetElement(System.Windows.DependencyObject)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ElementControllersCollection.Count">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ElementControllersCollection.Add(MathCore.WPF.ElementController)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ElementControllersCollection.Remove(MathCore.WPF.ElementController)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ElementControllersCollection.Clear">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ElementControllersCollection.System#Collections#Generic#ICollection{MathCore#WPF#ElementController}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ElementControllersCollection.System#Collections#Generic#IList{MathCore#WPF#ElementController}#Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ElementControllersCollection.System#Collections#Generic#ICollection{MathCore#WPF#ElementController}#Contains(MathCore.WPF.ElementController)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ElementControllersCollection.System#Collections#Generic#ICollection{MathCore#WPF#ElementController}#CopyTo(MathCore.WPF.ElementController[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ElementControllersCollection.System#Collections#Generic#IList{MathCore#WPF#ElementController}#IndexOf(MathCore.WPF.ElementController)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ElementControllersCollection.System#Collections#Generic#IList{MathCore#WPF#ElementController}#Insert(System.Int32,MathCore.WPF.ElementController)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ElementControllersCollection.System#Collections#Generic#IList{MathCore#WPF#ElementController}#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ElementControllersCollection.System#Collections#Generic#IEnumerable{MathCore#WPF#ElementController}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ElementControllersCollection.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.Model">
            <summary>Модель конструируемого динамического объекта для передачи в контекст данных представления</summary>
        </member>
        <member name="F:MathCore.WPF.Model._Properties">
            <summary>Коллекция свойств объекта</summary>
        </member>
        <member name="F:MathCore.WPF.Model._ModelObject">
            <summary>Динамический объект для доступа к свойствам</summary>
        </member>
        <member name="P:MathCore.WPF.Model.Object">
            <summary>Динамический объект для доступа к свойствам</summary>
        </member>
        <member name="P:MathCore.WPF.Model.Properties">
            <summary>Коллекция свойств объекта</summary>
        </member>
        <member name="M:MathCore.WPF.Model.OnPropertiesChanged(System.Object,System.EventArgs)">
            <summary>Перехват событий свойст, возникающих при изменении их значений</summary>
            <param name="sender">Свойство - источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="P:MathCore.WPF.Model.Item(System.String)">
            <summary>Индексатор по имени свойства</summary>
            <param name="Name">Имя требуемого свойства</param>
            <returns>Свойство боъекта с указанным именем</returns>
        </member>
        <member name="M:MathCore.WPF.Model.#ctor">
            <summary>Инициализация новой динамической модели объекта</summary>
        </member>
        <member name="M:MathCore.WPF.Model.GetProperty(System.String)">
            <summary>Получить свойство боъекта по указанному имени</summary>
            <param name="Name">Имя свойства объекта</param>
            <returns>Свойство объекта с указанным имененм, либо пустота, если свойство отсутствует</returns>
        </member>
        <member name="M:MathCore.WPF.Model.TrySetValue(System.String,System.Object,System.Boolean)">
            <summary>Попытаться установить значение свойства по указанному имени</summary>
            <param name="PropertyName">Имя устанавливаемого свойства</param>
            <param name="Value">Устанавливаемое значение свойства</param>
            <param name="CreateNewProperty">Создать новое свойство, если свойство с указанным имененм не было найдено</param>
            <returns>Истина, если удалось установить значение свойства, ложь - если свойство отсутсвует и не было создано</returns>
        </member>
        <member name="M:MathCore.WPF.Model.TryGetValue(System.String,System.Object@)">
            <summary>Попытаться получить значение свойства</summary>
            <param name="PropertyName">Имя свойства, значение которого требуется получить</param>
            <param name="Value">Получаемое значение свойства</param>
            <returns>Истина, если свойство было найдено и значение было получпено</returns>
        </member>
        <member name="M:MathCore.WPF.Model.ContainsProperty(System.String)">
            <summary>Проверка - существует ли свойство в модели</summary>
            <param name="Name"></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.WPF.Model.AddChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Model.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Передача события изменения свойства в динамический объект доступа</summary>
            <param name="Sender">Источник события - изменившееся свойство</param>
            <param name="E">Аргумент события и имененм свойства в изменившемся объекте-свойстве модели</param>
        </member>
        <member name="M:MathCore.WPF.Model.AddText(System.String)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.Model.CreateInstanceCore">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.ModelPropertiesCollection">
            <summary>Колекция свойств модели</summary>
        </member>
        <member name="E:MathCore.WPF.ModelPropertiesCollection.PropertyChanged">
            <summary>Событие возникает, когда одно из свойств коллекции меняет свой значение</summary>
        </member>
        <member name="M:MathCore.WPF.ModelPropertiesCollection.OnPropertyChanged(System.Object,System.EventArgs)">
            <summary>Генерация события изменения значения свойства коллекции</summary>
            <param name="sender">Источник события - одно из свойств коллекции </param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="F:MathCore.WPF.ModelPropertiesCollection._Properties">
            <summary>Словарь свойств по имени</summary>
        </member>
        <member name="P:MathCore.WPF.ModelPropertiesCollection.Item(System.String)">
            <summary>Определение свойства по имени</summary>
            <param name="Name">Имя требуемого свойства</param>
            <returns>Свойство с указанным именем</returns>
        </member>
        <member name="M:MathCore.WPF.ModelPropertiesCollection.Contains(System.String)">
            <summary>Определение - содержится ли свойство с указанным имененм в коллеции</summary>
            <param name="PropertyName">Имя проверяемого свойства</param>
            <returns>Истина, если свойство с указанным имененм содержится в коллекции</returns>
        </member>
        <member name="M:MathCore.WPF.ModelPropertiesCollection.TryGetValue(System.String,MathCore.WPF.ModelProperty@)">
            <summary>Попытаться получить свойство из коллекции по указанному имени</summary>
            <param name="PropertyName">Имя свойства, которое требуется получить из коллекции</param>
            <param name="property">Свойство с указанным имененм</param>
            <returns>Истина, если свойство было получено успешно</returns>
        </member>
        <member name="M:MathCore.WPF.ModelPropertiesCollection.ClearItems">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ModelPropertiesCollection.SetItem(System.Int32,MathCore.WPF.ModelProperty)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ModelPropertiesCollection.RemoveItem(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ModelPropertiesCollection.InsertItem(System.Int32,MathCore.WPF.ModelProperty)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.ModelProperty">
            <summary>Свойство модели</summary>
        </member>
        <member name="F:MathCore.WPF.ModelProperty.ValueProperty">
            <summary>Значение свойства</summary>
        </member>
        <member name="E:MathCore.WPF.ModelProperty.PropertyChanged">
            <summary>Событие, возникает когда значение свойства модели меняется</summary>
        </member>
        <member name="M:MathCore.WPF.ModelProperty.OnPropertyChanged(System.String)">
            <summary>Генерация события изменения значения свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="P:MathCore.WPF.ModelProperty.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="P:MathCore.WPF.ModelProperty.Name">
            <summary>Имя свойства модели</summary>
        </member>
        <member name="M:MathCore.WPF.ModelProperty.#ctor">
            <summary>Инициализация нового свойства модели</summary>
        </member>
        <member name="M:MathCore.WPF.ModelProperty.#ctor(System.String)">
            <summary>Инициализация нового свойства модели</summary>
            <param name="Name">Имя свойства модели</param>
        </member>
        <member name="M:MathCore.WPF.ModelProperty.#ctor(System.String,System.Object)">
            <summary>Инициализация нового свойства модели</summary>
            <param name="Name">Имя свойства модели</param>
            <param name="Value">Значение свйоства модели</param>
        </member>
        <member name="M:MathCore.WPF.ModelProperty.CreateInstanceCore">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.ModelObject">
            <summary>Динамический объект доступа к свйоствам модели</summary>
        </member>
        <member name="E:MathCore.WPF.ModelObject.PropertyChanged">
            <summary>Событие возникает в момент изменения значения свойства модели</summary>
        </member>
        <member name="M:MathCore.WPF.ModelObject.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменеия свйоства модели</summary>
            <param name="PropertyName"></param>
        </member>
        <member name="F:MathCore.WPF.ModelObject._Model">
            <summary>Модель, доступ к свойствам которой осуществляет динамический объект</summary>
        </member>
        <member name="M:MathCore.WPF.ModelObject.#ctor(MathCore.WPF.Model)">
            <summary>Инициализация нового динамического объекта доступа к свойствам модели</summary>
            <param name="Model"></param>
        </member>
        <member name="M:MathCore.WPF.ModelObject.PropertyChangeValue(System.String)">
            <summary>Уведомление динамического боъекта о том, что его свойство изменилось</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="M:MathCore.WPF.ModelObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ModelObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.MouseWheelBinding.Gesture">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.MouseWheelGesture.Matches(System.Object,System.Windows.Input.InputEventArgs)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.ObservableCollectionSyncWrapper`1">
            <summary>Потокобезопасная обёртка для <see cref="T:System.Collection.ObjectModel.ObservableCollection[T]"/></summary>
            <typeparam name="T">Тип элемента коллекции</typeparam>
        </member>
        <member name="M:MathCore.WPF.DeferredRefreshObservableCollection`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raises the <see cref="E:CollectionChanged" /> event.
            </summary>
            <param name="e">The instance containing the event data.</param>
        </member>
        <member name="M:MathCore.WPF.DeferredRefreshObservableCollection`1.DeferRefresh">
            <summary>Отложить посылку уведомлений об изменении состава коллекции</summary><returns>Дескриптор</returns>
        </member>
        <member name="T:MathCore.WPF.DeferredRefreshObservableCollection`1.DeferRefreshHelper">
            <summary>Дескриптор отложенных изменений</summary>
        </member>
        <member name="M:MathCore.WPF.DeferredRefreshObservableCollection`1.DeferRefreshHelper.Dispose">
            <summary>Уменьшить счетчик отложенной посылки обновлений</summary>
        </member>
        <member name="T:MathCore.WPF.PasswordBoxEx">
            <summary>Класс прикрепляемых свойств-зависимости для работы с <see cref="T:System.Windows.Controls.PasswordBox"/></summary>
        </member>
        <member name="F:MathCore.WPF.PasswordBoxEx.AttachProperty">
            <summary>Прикрепляемое свойство-зависимости, устанавливающее связь для дальнейшей работы с <see cref="T:System.Windows.Controls.PasswordBox"/></summary>
        </member>
        <member name="M:MathCore.WPF.PasswordBoxEx.SetAttach(System.Windows.DependencyObject,System.Boolean)">
            <summary>Установка значения свойства присоединения</summary>
            <param name="o">Объект для которого производится установка значения</param>
            <param name="v">Устанавливаемое значение</param>
        </member>
        <member name="F:MathCore.WPF.PasswordBoxEx.WaterMarkTextProperty">
            <summary>Текст, замещающий пустое пространство при отсутствии ввода пароля</summary>
        </member>
        <member name="F:MathCore.WPF.PasswordBoxWatcher.PasswordProperty">
            <summary>Пароль</summary>
        </member>
        <member name="P:MathCore.WPF.PasswordBoxWatcher.Password">
            <summary>Пароль</summary>
        </member>
        <member name="M:MathCore.WPF.PasswordBoxWatcher.OnHandlePasswordChanged(System.Object,System.Windows.RoutedEventArgs)">
            <summary>Обработчик события изменения пароля</summary>
            <param name="sender">Источник события - должен быть полем ввода пароля</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="T:MathCore.WPF.PasswordBoxHelper">
            <summary>
            Creates a bindable attached property for the <see cref="P:System.Windows.Controls.PasswordBox.SecurePassword"/> property.
            </summary>
        </member>
        <member name="T:MathCore.WPF.PasswordBoxHelper.PasswordBindingMarshaller">
            <summary>
            Encapsulated event logic
            </summary>
        </member>
        <member name="T:MathCore.WPF.Properties.Resources">
            <summary>
              Класс ресурса со строгой типизацией для поиска локализованных строк и т.д.
            </summary>
        </member>
        <member name="P:MathCore.WPF.Properties.Resources.ResourceManager">
            <summary>
              Возвращает кэшированный экземпляр ResourceManager, использованный этим классом.
            </summary>
        </member>
        <member name="P:MathCore.WPF.Properties.Resources.Culture">
            <summary>
              Перезаписывает свойство CurrentUICulture текущего потока для всех
              обращений к ресурсу с помощью этого класса ресурса со строгой типизацией.
            </summary>
        </member>
        <member name="M:MathCore.WPF.RadialProgressIndicator.#cctor">
            <summary>Static meta data registrations</summary>
        </member>
        <member name="M:MathCore.WPF.RadialProgressIndicator.#ctor">
            <summary>Initalizes a new instance of <see cref="T:MathCore.WPF.RadialProgressIndicator" /></summary>
        </member>
        <member name="F:MathCore.WPF.RadialProgressIndicator.ForegroundProperty">
            <summary>Dependency property for Foreground</summary>
        </member>
        <member name="P:MathCore.WPF.RadialProgressIndicator.Foreground">
            <summary>Foreground property</summary>
        </member>
        <member name="F:MathCore.WPF.RadialProgressIndicator.ActiveForegroundProperty">
            <summary>Dependency property for ActiveForeground</summary>
        </member>
        <member name="P:MathCore.WPF.RadialProgressIndicator.ActiveForeground">
            <summary>
                ActiveForeground property.
            </summary>
        </member>
        <member name="F:MathCore.WPF.RadialProgressIndicator.CurrentValueProperty">
            <summary>
                Dependency property for CurrentValue.
            </summary>
        </member>
        <member name="P:MathCore.WPF.RadialProgressIndicator.CurrentValue">
            <summary>Current value property.</summary>
        </member>
        <member name="M:MathCore.WPF.RadialProgressIndicator.OnRender(System.Windows.Media.DrawingContext)">
            <summary>
                When overridden in a derived class, participates in rendering operations
                that are directed by the layout system. The rendering instructions for this
                element are not used directly when this method is invoked, and are instead
                preserved for later asynchronous use by layout and drawing.
            </summary>
            <param name="DrawingContext">
                The drawing instructions for a specific element. This context is provided
                to the layout system.
            </param>
        </member>
        <member name="M:MathCore.WPF.RadialProgressIndicator.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
            <summary>
                Raises the System.Windows.FrameworkElement.SizeChanged event, using the specified
                information as part of the eventual event data.
            </summary>
            <param name="SizeInfo">
            </param>
        </member>
        <member name="M:MathCore.WPF.GeometryExtensions.EaseAngle(System.Double)">
            <summary>
                Easing in angle by delta proportionally 5 percent towards 360.
            </summary>
            <param name="angle">
                The angle to start.
            </param>
            <returns>
                Increased angle eased in by delta proportionally 5 percent towards 360.
            </returns>
        </member>
        <member name="M:MathCore.WPF.GeometryExtensions.Angle(System.Double,System.Double)">
            <summary>
                Increases the angle by the delta and ensure the final result is in
                -360 to 360 degrees.
            </summary>
            <param name="angle">
                The angle in degrees to increase.
            </param>
            <param name="delta">
                The delta angle in degree to increase by.
            </param>
            <returns>
                The angle increased by delta and ensure the final result is in
                -360 to 360 degrees.
            </returns>
        </member>
        <member name="M:MathCore.WPF.GeometryExtensions.Angle(System.Double)">
            <summary>
                Converts the percent from 0 to 100 into proportional angle from 0 to 360.
            </summary>
            <param name="percent">
                The percent to convert.
            </param>
            <returns>
                The converted angle from 0 to 360 proportional to 0 to 100 percent.
            </returns>
        </member>
        <member name="M:MathCore.WPF.GeometryExtensions.CreatePath(System.Windows.Point,System.Double,System.Double,System.Double)">
            <summary>
                Creates a circle path for the specified location, angle in degrees, circle radius and inner radius.
            </summary>
            <param name="location">
                The start location.
            </param>
            <param name="angle">
                The angle in degrees.
            </param>
            <param name="radius">
                The radius.
            </param>
            <param name="InnerRadius">
                Inner radius.
            </param>
            <returns>
                The circle path for the specified location, angle in degrees, circle radius and inner radius.
            </returns>
        </member>
        <member name="M:MathCore.WPF.GeometryExtensions.Create(System.Windows.Point,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
                Creates a circle path spilits into the given number of sigments.
            </summary>
            <param name="point">
                The start location.
            </param>
            <param name="segments">
                Number of sigments.
            </param>
            <param name="margin">
                Sigment distance between each other in degrees.
            </param>
            <param name="radius">
                The radius.
            </param>
            <param name="InnerRadius">
                The inner radius.
            </param>
            <returns>
                The combined path geomerty of the circle spilits into the number of segments.
            </returns>
        </member>
        <member name="M:MathCore.WPF.GeometryExtensions.ConvertRadianToCartesian(System.Double,System.Double)">
            <summary>
                Gets the vector point for the specified angle in degrees and radius.
            </summary>
            <param name="angle">
                The angle in degrees.
            </param>
            <param name="radius">
                The radius.
            </param>
            <returns>
                The vector point for the specified angle in degrees and radius.
            </returns>
        </member>
        <member name="M:MathCore.WPF.GeometryExtensions.Normalize(System.Double)">
            <summary>
                Normalizes the specified angle in degrees to angles between 0 to 360;
            </summary>
            <param name="angle">
                The angle to normalize.
            </param>
            <returns>
                Normalized angle in degrees from 0 to 360 for the specified <paramref name="angle" />
            </returns>
        </member>
        <member name="M:MathCore.WPF.GeometryExtensions.EaseIn(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                Impelement the EaseIn style of exponential animation which is one of exponential growth.
            </summary>
            <param name="TimeFraction">
                Time we've been running from 0 to 1.
            </param>
            <param name="start">
                Start value.
            </param>
            <param name="delta">
                Delta between start value and the end value we want.
            </param>
            <param name="power">
                The rate of exponental growth.
            </param>
            <returns>
                The result value.
            </returns>
        </member>
        <member name="M:MathCore.WPF.GeometryExtensions.EaseOut(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                Impelement the EaseOut style of exponential animation which is one of exponential decay.
            </summary>
            <param name="TimeFraction">
                Time we've been running from 0 to 1.
            </param>
            <param name="start">
                Start value.
            </param>
            <param name="delta">
                Delta between start value and the end value we want.
            </param>
            <param name="power">
                The rate of exponental decay.
            </param>
            <returns>
                The result value.
            </returns>
        </member>
        <member name="M:MathCore.WPF.GeometryExtensions.EaseInOut(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                Impelement the EaseInOut style of exponential animation which is one of exponential growth
                for the first half of the animation and one of exponential decay for the second half.
            </summary>
            <param name="TimeFraction">
                Time we've been running from 0 to 1.
            </param>
            <param name="start">
                Start value.
            </param>
            <param name="delta">
                Delta between start value and the end value we want.
            </param>
            <param name="power">
                The rate of exponental growth/decay.
            </param>
            <returns>
                The result value.
            </returns>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.AreClose(System.Double,System.Double)">
            <summary>
                AreClose - Returns whether or not two doubles are "close".  That is, whether or
                not they are within epsilon of each other.  Note that this epsilon is proportional
                to the numbers themselves to that AreClose survives scalar multiplication.
                There are plenty of ways for this to return false even for numbers which
                are theoretically identical, so no code calling this should fail to work if this
                returns false.  This is important enough to repeat:
                NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
                used for optimizations *only*.
            </summary>
            <returns>
                bool - the result of the AreClose comparision.
            </returns>
            <param name="value1"> The first double to compare. </param>
            <param name="value2"> The second double to compare. </param>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.AreClose(System.Windows.Size,System.Windows.Size)">
            <summary>
                Compares two Size instances for fuzzy equality.  This function
                helps compensate for the fact that double values can
                acquire error when operated upon
            </summary>
            <param name='size1'>The first size to compare</param>
            <param name='size2'>The second size to compare</param>
            <returns>Whether or not the two Size instances are equal</returns>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.AreClose(System.Windows.Point,System.Windows.Point)">
            <summary>
                Compares two points for fuzzy equality.  This function
                helps compensate for the fact that double values can
                acquire error when operated upon
            </summary>
            <param name='point1'>The first point to compare</param>
            <param name='point2'>The second point to compare</param>
            <returns>Whether or not the two points are equal</returns>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.AreClose(System.Windows.Vector,System.Windows.Vector)">
            <summary>
                Compares two Vector instances for fuzzy equality.  This function
                helps compensate for the fact that double values can
                acquire error when operated upon
            </summary>
            <param name='vector1'>The first Vector to compare</param>
            <param name='vector2'>The second Vector to compare</param>
            <returns>Whether or not the two Vector instances are equal</returns>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.LessThan(System.Double,System.Double)">
            <summary>
                LessThan - Returns whether or not the first double is less than the second double.
                That is, whether or not the first is strictly less than *and* not within epsilon of
                the other number.  Note that this epsilon is proportional to the numbers themselves
                to that AreClose survives scalar multiplication.  Note,
                There are plenty of ways for this to return false even for numbers which
                are theoretically identical, so no code calling this should fail to work if this
                returns false.  This is important enough to repeat:
                NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
                used for optimizations *only*.
            </summary>
            <returns>
                bool - the result of the LessThan comparision.
            </returns>
            <param name="value1"> The first double to compare. </param>
            <param name="value2"> The second double to compare. </param>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.GreaterThan(System.Double,System.Double)">
            <summary>
                GreaterThan - Returns whether or not the first double is greater than the second double.
                That is, whether or not the first is strictly greater than *and* not within epsilon of
                the other number.  Note that this epsilon is proportional to the numbers themselves
                to that AreClose survives scalar multiplication.  Note,
                There are plenty of ways for this to return false even for numbers which
                are theoretically identical, so no code calling this should fail to work if this
                returns false.  This is important enough to repeat:
                NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
                used for optimizations *only*.
            </summary>
            <returns>
                bool - the result of the GreaterThan comparision.
            </returns>
            <param name="value1"> The first double to compare. </param>
            <param name="value2"> The second double to compare. </param>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.LessThanOrClose(System.Double,System.Double)">
            <summary>
                LessThanOrClose - Returns whether or not the first double is less than or close to
                the second double.  That is, whether or not the first is strictly less than or within
                epsilon of the other number.  Note that this epsilon is proportional to the numbers
                themselves to that AreClose survives scalar multiplication.  Note,
                There are plenty of ways for this to return false even for numbers which
                are theoretically identical, so no code calling this should fail to work if this
                returns false.  This is important enough to repeat:
                NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
                used for optimizations *only*.
            </summary>
            <returns>
                bool - the result of the LessThanOrClose comparision.
            </returns>
            <param name="value1"> The first double to compare. </param>
            <param name="value2"> The second double to compare. </param>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.GreaterThanOrClose(System.Double,System.Double)">
            <summary>
                GreaterThanOrClose - Returns whether or not the first double is greater than or close to
                the second double.  That is, whether or not the first is strictly greater than or within
                epsilon of the other number.  Note that this epsilon is proportional to the numbers
                themselves to that AreClose survives scalar multiplication.  Note,
                There are plenty of ways for this to return false even for numbers which
                are theoretically identical, so no code calling this should fail to work if this
                returns false.  This is important enough to repeat:
                NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
                used for optimizations *only*.
            </summary>
            <returns>
                bool - the result of the GreaterThanOrClose comparision.
            </returns>
            <param name="value1"> The first double to compare. </param>
            <param name="value2"> The second double to compare. </param>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.IsOne(System.Double)">
            <summary>
                IsOne - Returns whether or not the double is "close" to 1.  Same as AreClose(double, 1),
                but this is faster.
            </summary>
            <returns>
                bool - the result of the AreClose comparision.
            </returns>
            <param name="value"> The double to compare to 1. </param>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.IsZero(System.Double)">
            <summary>
                IsZero - Returns whether or not the double is "close" to 0.  Same as AreClose(double, 0),
                but this is faster.
            </summary>
            <returns>
                bool - the result of the AreClose comparision.
            </returns>
            <param name="value"> The double to compare to 0. </param>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.IsFinite(System.Double)">
            <summary>
                Test to see if a double is a finite number (is not NaN or Infinity).
            </summary>
            <param name='value'>
                The value to test.
            </param>
            <returns>
                Whether or not the value is a finite number.
            </returns>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.IsValidSize(System.Double)">
            <summary>
                Test to see if a double a valid size value (is finite and > 0).
            </summary>
            <param name='value'>
                The value to test.
            </param>
            <returns>
                Whether or not the value is a valid size value.
            </returns>
        </member>
        <member name="M:MathCore.WPF.DoubleUtil.IsNaN(System.Double)">
            <summary>
                Checks whether the double value is not a valid number or not. The standard CLR double.IsNaN()
                function is approximately 100 times slower than this, so please make sure to use DoubleUtil.IsNaN()
                in performance sensitive code.
            </summary>
            <param name="value">
                The double value to check for.
            </param>
            <returns>
                True if <paramref name="value" /> is not a number. Otherwise true.
            </returns>
        </member>
        <member name="T:MathCore.WPF.ReadOnlyObservableLamdaCollection`2">
            <summary>Наблюдаемая коллекция элементов, построенная на другой наблюдаемой коллекции элементов с указаинем метода преобразвоания элементов</summary>
            <typeparam name="TSourceItem">Тим элементов исходной коллекции</typeparam>
            <typeparam name="TCollectionItem">Тип требуемых элементов</typeparam>
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.NotSupported(System.String)">
            <summary>Генерация исключения при вызове метода интерфейса, не поддерживаемого данной коллекцией</summary>
            <param name="Method">Имя вызываемого метода</param>
            <returns>Исключение <see cref="T:System.NotSupportedException"/></returns>
        </member>
        <member name="E:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.CollectionChanged">
            <summary>Событие возникает когда наблюдаемая коллекция меняется</summary>
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>Генерация события изменения коллекции</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.OnCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>Обработчик событий изменения в наблюдаемой коллекции</summary>
            <param name="sender">Источник события - наблюдаемая коллекция</param>
            <param name="e">Аргумент события, определяющий тип изменеия наблюдаемой коллекции</param>
        </member>
        <member name="E:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.PropertyChanged">
            <summary>Событие возникает когда изменяется одно из свойств наблюдаемой коллекции</summary>
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Генерация события изменеия свойства коллекции</summary>
            <param name="args">Аргумент события изменения свойства, хранящий имя изменившегося свойства</param>
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Обработчик события изменеий свойств наблюдаемой коллекции</summary>
            <param name="sender">Источник события - наблюдаемая коллекция</param>
            <param name="e">Аргумент события - хранящий имя изменившегося свойства</param>
        </member>
        <member name="F:MathCore.WPF.ReadOnlyObservableLamdaCollection`2._Collection">
            <summary>Наблюдаемая коллекция</summary>
        </member>
        <member name="F:MathCore.WPF.ReadOnlyObservableLamdaCollection`2._Converter">
            <summary>Метод преобразования элементов наблюдаемой коллекции в элементы конечной коллекции</summary>
        </member>
        <member name="P:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.Count">
            <summary>Число элементов коллекции</summary>
        </member>
        <member name="P:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.OutElementCollection">
            <summary>Перечисление преобразованных элементов исходной коллекции указанным методом преобразвоания</summary>
        </member>
        <member name="P:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.Item(System.Int32)">
            <summary>Элемент коллекции с указанным индексом</summary>
            <param name="index">Индекс элемента коллекции</param>
            <returns>Элемент коллекции с указанным индексом</returns>
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.#ctor(System.Collections.ObjectModel.ObservableCollection{`0},System.Func{`0,`1})">
            <summary>Инициализация новой наблюдаемой коллекции элементов требуемого типа</summary>
            <param name="collection">Исходная наблюдаемая коллекция</param>
            <param name="converter">Метод преобразования элементов</param>
        </member>
        <member name="P:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#ICollection{TCollectionItem}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#ICollection{TCollectionItem}#Add(`1)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#ICollection{TCollectionItem}#Remove(`1)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#ICollection{TCollectionItem}#Contains(`1)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#ICollection{TCollectionItem}#CopyTo(`1[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#ICollection{TCollectionItem}#Clear">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#ICollection#SyncRoot">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#ICollection#IsSynchronized">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#IList{TCollectionItem}#Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#IList{TCollectionItem}#Insert(System.Int32,`1)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#IList{TCollectionItem}#IndexOf(`1)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IList#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IList#IsFixedSize">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IList#Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IList#Add(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#IList{TCollectionItem}#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IList#Contains(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IList#IndexOf(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IList#Insert(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IList#Remove(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IList#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IList#Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#Generic#IEnumerable{TCollectionItem}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ReadOnlyObservableLamdaCollection`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ResizingAdorner.#ctor(System.Windows.UIElement)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.RichTextBoxHelper.GetWordRange(System.Windows.Documents.TextPointer)">
            <summary>
            Returns a TextRange covering a word containing or following this TextPointer.
            </summary>
            <remarks>
            If this TextPointer is within a word or at start of word, the containing word range is returned.
            If this TextPointer is between two words, the following word range is returned.
            If this TextPointer is at trailing word boundary, the following word range is returned.
            </remarks>
        </member>
        <member name="M:MathCore.WPF.RichTextBoxHelper.GetPositionAtWordBoundary(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)">
            <summary>
            1.  When WordBreakDirection = Forward, returns a position at the end of the word,
                i.e. a position with a wordBreak character (space) following it.
            2.  When WordBreakDirection = Backward, returns a position at the start of the word,
                i.e. a position with a wordBreak character (space) preceeding it.
            3.  Returns null when there is no workbreak in the requested direction.
            </summary>
        </member>
        <member name="F:MathCore.WPF.RowDefinitionCollapsable.VisibleProperty">
            <summary>Видимость</summary>
        </member>
        <member name="P:MathCore.WPF.RowDefinitionCollapsable.Visible">
            <summary>Видимость</summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgAElement">
            <summary>
              Represents an &lt;a&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgBaseElement">
            <summary>
              Base class for all other SVG elements.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgCircleElement">
            <summary>
              Represents an &lt;circle&gt; element.
            </summary>
        </member>
        <member name="F:MathCore.WPF.SVG.SvgCircleElement.CenterX">
            <summary>
              The x-coordinate of the circle's center.
            </summary>
        </member>
        <member name="F:MathCore.WPF.SVG.SvgCircleElement.CenterY">
            <summary>
              The y-coordinate of the circle's center.
            </summary>
        </member>
        <member name="F:MathCore.WPF.SVG.SvgCircleElement.Radius">
            <summary>
              The circle's radius.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgClipPathElement">
            <summary>
              Represents a &lt;clipPath&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgColor">
            <summary>
              Represents an RGB color.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgColorPaint">
            <summary>
              A paint with a solid color.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgContainerBaseElement">
            <summary>
              Base element for all container elements.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgCoordinate">
            <summary>
              A coordinate.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgDefsElement">
            <summary>
              Represents a &lt;defs&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgEllipseElement">
            <summary>
              Represents an &lt;ellipse&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgFEBlendElement">
            <summary>
              Represents an &lt;feBlend&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgFEColorMatrixElement">
            <summary>
              Represents an &lt;feColorMatrix&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgFEGaussianBlurElement">
            <summary>
              Represents an &lt;feGaussianBlur&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgFilterEffectBaseElement">
            <summary>
              Represents a &lt;filterEffect&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgFilterElement">
            <summary>
              Represents a &lt;filter&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgFlowParaElement">
            <summary>
              Represents a &lt;flowPara&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgFlowRegionElement">
            <summary>
              Represents a &lt;flowRegíon&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgFlowRootElement">
            <summary>
              Represents a &lt;flowRoot&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgFlowSpanElement">
            <summary>
              Represents a &lt;flowSpan&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgForeignObjectElement">
            <summary>
              Represents a &lt;foreignObject&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgGElement">
            <summary>
              Represents a &lt;g&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgImage">
            <summary>
              A <see cref="T:System.Windows.Markup.MarkupExtension"/> for loading SVG images.
            </summary>
        </member>
        <member name="M:MathCore.WPF.SVG.SvgImage.#ctor">
            <summary>
              Initializes a new <see cref="T:MathCore.WPF.SVG.SvgImage"/> instance.
            </summary>
        </member>
        <member name="M:MathCore.WPF.SVG.SvgImage.#ctor(System.Uri)">
            <summary>
              Initializes a new <see cref="T:MathCore.WPF.SVG.SvgImage"/> instance.
            </summary>
            <param name="uri">
              The location of the SVG document.
            </param>
        </member>
        <member name="M:MathCore.WPF.SVG.SvgImage.ProvideValue(System.IServiceProvider)">
            <summary>
              Overrides <see cref="M:System.Windows.Markup.MarkupExtension.ProvideValue(System.IServiceProvider)"/> and returns the 
              <see cref="T:System.Windows.Media.DrawingImage"/> the SVG document is rendered into.
            </summary>
            <param name="serviceProvider">
              Object that can provide services for the markup extension; 
              <paramref name="serviceProvider"/> is not used.
            </param>
            <returns>
              The <see cref="T:System.Windows.Media.DrawingImage"/> the SVG image is rendered into or 
              <c>null</c> in case there has been an error while parsing or 
              rendering.
            </returns>
        </member>
        <member name="P:MathCore.WPF.SVG.SvgImage.Uri">
            <summary>
              Gets or sets the location of the SVG image.
            </summary>
        </member>
        <member name="P:MathCore.WPF.SVG.SvgImage.IgnoreEffects">
            <summary>
              Gets or sets whether SVG filter effects should be transformed into
              WPF bitmap effects.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgImageElement">
            <summary>
              Represents an &lt;image&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgLinearGradientElement">
            <summary>
              Represents a &lt;linearGradient&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgLineElement">
            <summary>
              Represents a &lt;line&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgMarkerElement">
            <summary>
              Represents a &lt;marker&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgMaskElement">
            <summary>
              Represents a &lt;mask&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgMetadataElement">
            <summary>
              Represents a &lt;metadata&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgPathElement">
            <summary>
              Represents a &lt;path&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgPatternElement">
            <summary>
              Represents a &lt;pattern&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgReader">
            <summary>
              Provides methods to read (and render) SVG documents.
            </summary>
        </member>
        <member name="M:MathCore.WPF.SVG.SvgReader.Load(System.Xml.XmlReader,MathCore.WPF.SVG.SvgReaderOptions)">
            <summary>
              Loads an SVG document and renders it into a 
              <see cref="T:System.Windows.Media.DrawingImage"/>.
            </summary>
            <param name="reader">
              A <see cref="T:System.Xml.XmlReader"/> to read the XML structure of the SVG 
              document.
            </param>
            <param name="options">
              <see cref="T:MathCore.WPF.SVG.SvgReaderOptions"/> to use for parsing respectively 
              rendering the SVG document.
            </param>
            <returns>
              A <see cref="T:System.Windows.Media.DrawingImage"/> containing the rendered SVG document.
            </returns>
        </member>
        <member name="M:MathCore.WPF.SVG.SvgReader.Load(System.Xml.XmlReader)">
            <summary>
              Loads an SVG document and renders it into a 
              <see cref="T:System.Windows.Media.DrawingImage"/>.
            </summary>
            <param name="reader">
              A <see cref="T:System.Xml.XmlReader"/> to read the XML structure of the SVG 
              document.
            </param>
            <returns>
              A <see cref="T:System.Windows.Media.DrawingImage"/> containing the rendered SVG document.
            </returns>
        </member>
        <member name="M:MathCore.WPF.SVG.SvgReader.Load(System.IO.Stream,MathCore.WPF.SVG.SvgReaderOptions)">
            <summary>
              Loads an SVG document and renders it into a 
              <see cref="T:System.Windows.Media.DrawingImage"/>.
            </summary>
            <param name="stream">
              A <see cref="T:System.IO.Stream"/> to read the XML structure of the SVG 
              document.
            </param>
            <param name="options">
              <see cref="T:MathCore.WPF.SVG.SvgReaderOptions"/> to use for parsing respectively 
              rendering the SVG document.
            </param>
            <returns>
              A <see cref="T:System.Windows.Media.DrawingImage"/> containing the rendered SVG document.
            </returns>
        </member>
        <member name="M:MathCore.WPF.SVG.SvgReader.Load(System.IO.Stream)">
            <summary>
              Loads an SVG document and renders it into a 
              <see cref="T:System.Windows.Media.DrawingImage"/>.
            </summary>
            <param name="stream">
              A <see cref="T:System.IO.Stream"/> to read the XML structure of the SVG 
              document.
            </param>
            <returns>
              A <see cref="T:System.Windows.Media.DrawingImage"/> containing the rendered SVG document.
            </returns>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgReaderOptions">
            <summary>
              Defines a set of options to customize rendering repspectively reading 
              of SVG documents.
            </summary>
        </member>
        <member name="M:MathCore.WPF.SVG.SvgReaderOptions.#ctor">
            <summary>
              Initializes a new <see cref="T:MathCore.WPF.SVG.SvgReaderOptions"/> instance.
            </summary>
        </member>
        <member name="M:MathCore.WPF.SVG.SvgReaderOptions.#ctor(System.Boolean)">
            <summary>
              Initializes a new <see cref="T:MathCore.WPF.SVG.SvgReaderOptions"/> instance.
            </summary>
            <param name="ignoreEffects">
              Specifies whether filter effects should be applied using WPF bitmap 
              effects.
            </param>
        </member>
        <member name="P:MathCore.WPF.SVG.SvgReaderOptions.IgnoreEffects">
            <summary>
              Gets or sets whether SVG effects should either be ignored or 
              converted to <see cref="T:System.Windows.Media.Effects.BitmapEffect">bitmap effects</see>.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgRectElement">
            <summary>
              Represents a &lt;rect&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgStyleElement">
            <summary>
              Represents a &lt;style&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgSVGElement">
            <summary>
              Represents an &lt;svg&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgSwitchElement">
            <summary>
              Represents a &lt;switch&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgSymbolElement">
            <summary>
              Represents a &lt;symbol&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgTextElement">
            <summary>
              Represents a &lt;text&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgTSpanElement">
            <summary>
              Represents a &lt;tspan&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.SVG.SvgUseElement">
            <summary>
              Represents an &lt;use&gt; element.
            </summary>
        </member>
        <member name="T:MathCore.WPF.Temp.BarnsleyFern">
            <summary>
            http://en.wikipedia.org/wiki/Barnsley_fern
            </summary>
        </member>
        <member name="T:MathCore.WPF.TeX.AccentedAtom">
            <summary>Atom representing base atom with accent above it</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.AccentedAtom.BaseAtom">
            <summary>Atom over which accent symbol is placed</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.AccentedAtom.AccentAtom">
            <summary>Atom representing accent symbol to place over base atom</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.Atom">
            <summary>Atom (smallest unit) of TexFormula</summary>
        </member>
        <member name="M:MathCore.WPF.TeX.Atom.GetLeftType">
            <summary>Gets type of leftmost child item</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.WPF.TeX.Atom.GetRightType">
            <summary>Gets type of leftmost child item</summary>
            <returns></returns>
        </member>
        <member name="T:MathCore.WPF.TeX.BigOperatorAtom">
            <summary>Atom representing big operator with optional limits</summary>
        </member>
        <member name="M:MathCore.WPF.TeX.BigOperatorAtom.ChangeWidth(MathCore.WPF.TeX.Box,System.Double)">
            <summary>Centre specified box in new box of specified width, if necessary</summary>
            <param name="box"></param>
            <param name="maxWidth"></param>
            <returns></returns>
        </member>
        <member name="P:MathCore.WPF.TeX.BigOperatorAtom.BaseAtom">
            <summary>Atom representing big operator</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.BigOperatorAtom.LowerLimitAtom">
            <summary>Atoms representing lower and upper limits</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.BigOperatorAtom.UseVerticalLimits">
            <summary>True if limits should be drawn over and under the base atom; false if they should be drawn as scripts</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.CharAtom">
            <summary>Atom representing single character in specific text style</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.CharAtom.TextStyle">
            <summary>Null means default text style</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.CharFont">
            <summary>Single character together with specific font</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.CharInfo">
            <summary>Single character togeter with information about font and metrics</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.DefaultTexFont">
            <summary>Default implementation of ITeXFont that reads all font information from XML file</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.DefaultTexFontParser">
            <summary>Parses information for DefaultTeXFont settings from XML file</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.DummyAtom">
            <summary>Dummy atom representing atom whose type can change or which can be replaced by a ligature</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.FencedAtom">
            <summary>Atom representing base atom surrounded by delimeters</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.FixedCharAtom">
            <summary>Atom representing character that does not depend on text style</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.FractionAtom">
            <summary>Atom representing fraction, with or without separation line</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.Glue">
            <summary>Represents glueElement for holding together boxes</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.HorizontalBox">
            <summary>Box containing horizontal stack of child boxes</summary>
        </member>
        <member name="F:MathCore.WPF.TeX.MathView.ScaleProperty">
            <summary>Маштаб</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.MathView.Scale">
            <summary>Маштаб</summary>
        </member>
        <member name="F:MathCore.WPF.TeX.MathView.ForegroundProperty">
            <summary>Кисть отрисовки текста формулы</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.MathView.Foreground">
            <summary>Кисть отрисовки текста формулы</summary>
        </member>
        <member name="F:MathCore.WPF.TeX.MathView.BackgroundProperty">
            <summary>Кисть отрисовки заднего фона</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.MathView.Background">
            <summary>Кисть отрисовки заднего фона</summary>
        </member>
        <member name="F:MathCore.WPF.TeX.MathView.DataProperty">
            <summary>Строковое выражение</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.MathView.Data">
            <summary>Строковое выражение</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.OverBar">
            <summary>Box representing other box with horizontal rule above it</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.OverlinedAtom">
            <summary>Atom representing other atom with horizontal rule above it</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.OverUnderBox">
            <summary>Box representing other box with delimeter and script box over or under it</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.OverUnderBox.Kern">
            <summary>Kern between delimeter and Script</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.OverUnderBox.Over">
            <summary>True to draw delimeter and script over base; false to draw under base</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.OverUnderDelimiter.Kern">
            <summary>Kern between delimeter symbol and script</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.OverUnderDelimiter.Over">
            <summary> True to place delimeter symbol Over base; false to place delimeter symbol under base</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.PhantomAtom">
            <summary>Atom representing other atom that is not rendered</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.TexPredefinedFormulaSettingsParser">
            <summary>Parses settings for predefined formulas from XML file</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.Radical">
            <summary>Atom representing radical (nth-root) construction</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.ScriptsAtom">
            <summary>Atom representing scripts to attach to other atom</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.StyledAtom">
            <summary>Atom specifying graphical style</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.StyledAtom.RowAtom">
            <summary>RowAtom to which colors are applied</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.SymbolAtom">
            <summary>Atom representing symbol (non-alphanumeric character)</summary>
        </member>
        <member name="F:MathCore.WPF.TeX.SymbolAtom.symbols">
            <summary>Dictionary of definitions of all symbols, keyed by name</summary>
        </member>
        <member name="F:MathCore.WPF.TeX.SymbolAtom.validSymbolTypes">
            <summary>Set of all valid symbol types</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.TexEnvironment">
            <summary>Specifies current graphical parameters used to create boxes</summary>
        </member>
        <member name="F:MathCore.WPF.TeX.TexEnvironment.lastFontId">
            <summary>ID of font that was last used</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.TexFontInfo">
            <summary>Specifies all information about single font</summary>
        </member>
        <member name="P:MathCore.WPF.TeX.TexFontInfo.SkewCharacter">
            <summary>Skew character (used for positioning accents)</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.TexFontMetrics">
            <summary>Specifies font metrics for single character</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.TexFormula">
            <summary>Represents mathematical formula that can be rendered</summary>
        </member>
        <member name="F:MathCore.WPF.TeX.TexFormulaParser.isInitialized">
            <summary>True if parser has been initialized</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.TypedAtom">
            <summary>Atom representing other atom with custom left and right types</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.UnderlinedAtom">
            <summary>Atom representing other atom that is underlined</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.UnderOverAtom">
            <summary>Atom representing other atom with atoms optionally over and under it</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.VerticalBox">
            <summary>Box containing vertical stack of child boxes</summary>
        </member>
        <member name="T:MathCore.WPF.TeX.VerticalCenteredAtom">
            <summary>Atom representing other atom vertically centered with respect to axis</summary>
        </member>
        <member name="M:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.Count">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.WPF.ThreadSaveObservableCollectionWrapper`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.UserDialog">
            <summary>Пользовательский диалог</summary>
        </member>
        <member name="F:MathCore.WPF.UserDialog.WindowStyleProperty">
            <summary>Стиль окна диалога</summary>
        </member>
        <member name="P:MathCore.WPF.UserDialog.WindowStyle">
            <summary>Стиль окна диалога</summary>
        </member>
        <member name="F:MathCore.WPF.UserDialog.IsDialogDefaultProperty">
            <summary>Отображение по умолчанию в виде диалога</summary>
        </member>
        <member name="P:MathCore.WPF.UserDialog.IsDialogDefault">
            <summary>Отображение по умолчанию в виде диалога</summary>
        </member>
        <member name="F:MathCore.WPF.UserDialog.WindowContentProperty">
            <summary>Содержимое окна</summary>
        </member>
        <member name="P:MathCore.WPF.UserDialog.WindowContent">
            <summary>Содержимое окна</summary>
        </member>
        <member name="F:MathCore.WPF.UserDialog.TemplateProperty">
            <summary>Шаблон диалога</summary>
        </member>
        <member name="P:MathCore.WPF.UserDialog.Template">
            <summary>Шаблон диалога</summary>
        </member>
        <member name="F:MathCore.WPF.UserDialog.WindowIconProperty">
            <summary>Иконка окна диалога</summary>
        </member>
        <member name="P:MathCore.WPF.UserDialog.WindowIcon">
            <summary>Иконка окна диалога</summary>
        </member>
        <member name="F:MathCore.WPF.UserDialog.WindowWidthProperty">
            <summary>Ширина окна</summary>
        </member>
        <member name="P:MathCore.WPF.UserDialog.WindowWidth">
            <summary>Ширина окна</summary>
        </member>
        <member name="F:MathCore.WPF.UserDialog.WindowHeightProperty">
            <summary>Высота окна</summary>
        </member>
        <member name="P:MathCore.WPF.UserDialog.WindowHeight">
            <summary>Высота окна</summary>
        </member>
        <member name="P:MathCore.WPF.UserDialog.ShowCommand">
            <summary>Показать окно без блокировки</summary>
        </member>
        <member name="P:MathCore.WPF.UserDialog.ShowDialogCommand">
            <summary>Показать диалог в модальном режиме</summary>
        </member>
        <member name="M:MathCore.WPF.UserDialog.CanExecute(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.UserDialog.Execute(System.Object)">
            <inheritdoc />
        </member>
        <member name="E:MathCore.WPF.UserDialog.CanExecuteChanged">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ValidationRules.IsInteger.Validate(System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ValidationRules.NotNaN.Validate(System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ValidationRules.NotNull.Validate(System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ValidationRules.RegExp.Validate(System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ValidationRules.StringLength.Validate(System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="F:MathCore.WPF.Values.ScaleValue.ScreenLengthProperty">
            <summary>Размер экрана</summary>
        </member>
        <member name="P:MathCore.WPF.Values.ScaleValue.ScreenLength">
            <summary>Размер экрана</summary>
        </member>
        <member name="F:MathCore.WPF.Values.ScaleValue.ValueMinProperty">
            <summary>Отображаемый минимум</summary>
        </member>
        <member name="P:MathCore.WPF.Values.ScaleValue.ValueMin">
            <summary>Отображаемый минимум</summary>
        </member>
        <member name="F:MathCore.WPF.Values.ScaleValue.ValueMaxProperty">
            <summary>Отображаемый максимум</summary>
        </member>
        <member name="P:MathCore.WPF.Values.ScaleValue.ValueMax">
            <summary>Отображаемый максимум</summary>
        </member>
        <member name="F:MathCore.WPF.Values.ScaleValue.ValueOffsetProperty">
            <summary>Смещение значения</summary>
        </member>
        <member name="P:MathCore.WPF.Values.ScaleValue.ValueOffset">
            <summary>Смещение значения</summary>
        </member>
        <member name="F:MathCore.WPF.Values.ScaleValue.ScreenOffsetProperty">
            <summary>Экранное смещение</summary>
        </member>
        <member name="P:MathCore.WPF.Values.ScaleValue.ScreenOffset">
            <summary>Экранное смещение</summary>
        </member>
        <member name="F:MathCore.WPF.Values.ScaleValue.ValueProperty">
            <summary>Значение</summary>
        </member>
        <member name="P:MathCore.WPF.Values.ScaleValue.Value">
            <summary>Значение</summary>
        </member>
        <member name="F:MathCore.WPF.Values.ScaleValue.ScreenValueProperty">
            <summary>Экранное значение</summary>
        </member>
        <member name="P:MathCore.WPF.Values.ScaleValue.ScreenValue">
            <summary>Экранное значение</summary>
        </member>
        <member name="T:MathCore.WPF.ViewModels.DynamicViewModel">
            <summary>Динамическая визуальная объектная модель</summary>
        </member>
        <member name="E:MathCore.WPF.ViewModels.DynamicViewModel.PropertyChanged">
            <summary>Событие возникает в момент изменения значения свойства модели</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.OnPropertyChanged(System.String)">
            <summary>Генерация события изменения значения свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="F:MathCore.WPF.ViewModels.DynamicViewModel._PropertiesValues">
            <summary>Словарь значений свойств модели</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.DynamicViewModel._IndexersValues">
            <summary>Словарь значений индексаторов объекта</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.#ctor">
            <summary>Инициализация новой динамической модели-представления</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.#ctor(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>Инициализация новой динамической модели-представления</summary><param name="PropertiesDictionary">Словарь для хранения значений свойств объекта</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.SetPropertyValue(System.String,System.Object)">
            <summary>Установка значения свойства</summary>
            <param name="property">Имя изменяемого свойства</param>
            <param name="value">Значение, устанавливаемое для свойства</param>
            <returns>Истина, если значение было установлено</returns>
        </member>
        <member name="F:MathCore.WPF.ViewModels.DynamicViewModel.__Items_PropertyName">
            <summary>Имя свойства индексатора</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.SetIndexedValue(System.Object[],System.Object)">
            <summary>Установка индексированного значения</summary>
            <param name="indexes">Индексы значения</param>
            <param name="value">Устанавливаемое значение</param>
            <returns>Истина, если значение было установлено</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.TryGetPropertyValue(System.String,System.Object@)">
            <summary>Попытка получить значение свойства</summary>
            <param name="property">Имя свойства, значение которого требуется получить</param>
            <param name="value">Значение свойства</param>
            <returns>Истина, если значение свойства было определено до вызова метода</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.TryGetIndexedValue(System.Object[],System.Object@)">
            <summary>Попытка получить индексированное значение</summary>
            <param name="indexes">Индексы значения</param>
            <param name="value">Получаемое значение</param>
            <returns>Истина, если значение получить удалось</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ViewModels.DynamicViewModel.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.ViewModels.SettingsDialogViewModelConverter">
            <summary>Генератор модели-представления интерфейса настроек</summary>
            <remarks>
            В первый вложенный в окно контейнер надо добавить преобразователь контекста данных
            DataContext="{Binding Converter={u:SettingsDialogViewModelConverter}}
            </remarks>
        </member>
        <member name="F:MathCore.WPF.ViewModels.SettingsDialogViewModelConverter._DialogWindow">
            <summary>Диалоговое окно конфигурации</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModelConverter.ProvideValue(System.IServiceProvider)">
            <summary>Метод генерации значения, вставляемого в разметку</summary>
            <returns>Возвращает сам себя</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModelConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModelConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.WPF.ViewModels.SettingsDialogViewModel">
            <summary>Модель-представление диалогового окна настроек</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.SettingsDialogViewModel.PropertiesBindingTypes">
            <summary>Флаги привязки для поиска членов объекта конфигурации</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.SettingsDialogViewModel._ValueObject">
            <summary>Объект конфигурации, с которым работает окно диалога (контекст данных окна диалога)</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.SettingsDialogViewModel._KnownProperties">
            <summary>Перечень известных свойств объекта конфигурации, с которыми можно работать на чтение и на запись значений</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.SettingsDialogViewModel._DialogWindow">
            <summary>Окно диалога конфигурации</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.SettingsDialogViewModel._PropertiesDictionary">
            <summary>Текущий словарь значений параметров, которые устанавливаются в окне конфигурации и которые будут применены к объекту после выполнения команды <see cref="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.CommitCommand"/></summary>
        </member>
        <member name="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.PropertiesDictionary">
            <summary>Текущий словарь значений параметров, которые устанавливаются в окне конфигурации и которые будут применены к объекту после выполнения команды <see cref="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.CommitCommand"/></summary>
        </member>
        <member name="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.DialogWindow">
            <summary>Окно диалога конфигурации</summary>
        </member>
        <member name="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.Value">
            <summary>Динамический объект конфигурации</summary>
            <remarks>
            Служит для динамической привязки значений в XAML-разметке к виртуальным свойствам объекта конфигурации.
            При первом доступе к свойству (при чтении значения) выдаёт значение исходного объекта конфигурации
            При записи значения в свойство, сохраняет переданное значение в словаре и при последующий чтениях выдаёт записанное в словарь значение
            При закрытии окна с положительным диалоговым результатом копирует значения словаря в свойства исходного конфигурируемого объекта
            </remarks> 
        </member>
        <member name="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.ValueObject">
            <summary>Объект конфигурации, с которым работает окно диалога (контекст данных окна диалога)</summary>
        </member>
        <member name="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.HasChanges">
            <summary>Признак того, что значения динамического конфигурируемого объекта и исходного объекта расходятся (имеются записи в словаре значений)</summary>
        </member>
        <member name="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.KnownProperties">
            <summary>Перечень известных свойств объекта конфигурации, с которыми можно работать на чтение и на запись значений</summary>
        </member>
        <member name="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.CommitCommand">
            <summary>Команда сохранения значений конфигурации и закрытия окна диалога с положительным диалоговым результатом</summary>
        </member>
        <member name="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.RejectCommand">
            <summary>Команд отклонения внесённых изменений и закрытия диалогового окна с отрицательным диалоговым результатом</summary>
        </member>
        <member name="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.RestoreCommand">
            <summary>Команда отмены деланных изменений (очистка словаря значений свойств конфигурируемого объекта)</summary>
        </member>
        <member name="P:MathCore.WPF.ViewModels.SettingsDialogViewModel.CloseCommand">
            <summary>Команда закрытия диалогового окна с указанием диалогового результата</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModel.#ctor(System.Object,System.Windows.Window)">
            <summary>Инициализация новой модели-представления окна диалога конфигурации</summary>
            <param name="value">ООбъект конфигурации</param>
            <param name="window">Окно диалога конфигурации</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModel.#ctor">
            <summary>Инициализация новой модели-представления окна диалога конфигурации</summary>
            <remarks>Создаёт все команды, но не производит инициализацию модели устанавливая конфигурируемый объект и окно диалога</remarks>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModel.Initialize(System.Object,System.Windows.Window)">
            <summary>Инициализация модели-представления диалога конфигурации</summary>
            <param name="value">Объект конфигурации</param>
            <param name="window">Окно конфигурации</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModel.OnValuePropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Обработчик события изменения значения свойства динамического объекта конфигурации</summary>
            <param name="Sender">Источник события - динамический объект конфигурации</param>
            <param name="E">Аргумент события, определяющий имя изменившегося свойства</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModel.OnCommitCommandExecuted(System.Nullable{System.Boolean})">
            <summary>Обработчик вызова команды применения изменений в динамическом-конфигурационном объекте и закрытия диалогового окна с положительным диалоговым результатом</summary>
            <param name="DialogResult">Установленный диалоговый результат (по умолчанию - <see langword="true"/>)</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModel.OnRejectCommandExecuted(System.Nullable{System.Boolean})">
            <summary>Обработчик вызова команды отклонения сделанных в динамическом-конфигурационном объекте изменений и закрытия диалогового окна с отрицательным диалоговым результатом</summary>
            <param name="DialogResult">Установленный диалоговый результат (по умолчанию - <see langword="false"/>)</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModel.OnRestoreCommandExecuted">
            <summary>Обработчик вызова команды отклонения изменений, сделанных в динамическом объекте конфигурации без закрытия диалогового окна</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModel.OnCloseCommandExecuted(System.Nullable{System.Boolean})">
            <summary>Обработчик вызова команды закрытия диалогового окна с нейтральным диалоговым результатом</summary>
            <param name="DialogResult">Установленный диалоговый результат (по умолчанию - <see langword="null"/>)</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsDialogViewModel.CloseDialogWindow(System.Nullable{System.Boolean})">
            <summary>Метод закрытия диалогового кона с установленным диалоговым результатом</summary>
            <param name="DialogResult">Установленный диалоговый результат (по умолчанию - <see langword="null"/>)</param>
        </member>
        <member name="T:MathCore.WPF.ViewModels.SettingsObjectManager">
            <summary>Динамический объект конфигурации, осуществляющий доступ к виртуальным свойствам исходного конфигурируемого объекта</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.SettingsObjectManager._Value">
            <summary>Исходный конфигурируемый объект</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.SettingsObjectManager._ObjectProperties">
            <summary>Словарь дескрипторов открытых свойств исходного объекта, доступных для чтения и для записи значений</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.SettingsObjectManager._ObjectFields">
            <summary>Словарь дескрипторов открытых полей исходного объекта, доступных для чтения и для записи значений</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.SettingsObjectManager._ObjectIndexers">
            <summary>Словарь дескрипторов открытых индексаторов исходного объекта, доступных для чтения и для записи значений</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsObjectManager.#ctor(System.Object,System.Windows.Window,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>Создание нового динамического конфигурируемого объекта</summary>
            <param name="value">Исходный конфигурируемый объект</param>
            <param name="window">Окно диалога конфигурации</param>
            <param name="PropertiesDictionary">Словарь, в котором следует хранить временные значения устанавливаемых свойств конфигурируемого объекта</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsObjectManager.OnValuePropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Обработчик события изменений свойств конфигурируемого объекта в случае если он определяет интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
            <param name="Sender">Исходный конфигурируемый объект - источник события</param>
            <param name="E">Аргумент события, определяющий имя изменившегося свойства</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsObjectManager.OnDialogWindowClosed(System.Object,System.EventArgs)">
            <summary>Обработчик события закрытия диалогового окна</summary>
            <remarks>В случае положительного диалогового результат переписывает значения словаря значений свойств в свойства исходного конфигурируемого объекта</remarks>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsObjectManager.TryGetPropertyValue(System.String,System.Object@)">
            <inheritdoc />
            <remarks>Попытка определить значение свойства: если в словаре свойств существует значение по ключу - имени свойства, то оно будет передано в качестве значения</remarks>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsObjectManager.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <inheritdoc />
            <remarks>При отсутствии записи в словаре свойств производится поиск свойства исходного объекта и определение его значения</remarks>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsObjectManager.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <inheritdoc />
            <remarks>
            При записи значения свойства, если в исходном конфигурируемом объекте свойство с таким именем существует, 
            то сохраняем переданное значение в словаре, проводя предварительно преобразование типа перданного объекта в тип, поддерживаемый свойством
            </remarks>
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsObjectManager.GetDynamicMemberNames">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ViewModels.SettingsObjectManager.Restore">
            <summary>Отбросить все сделанные изменения</summary>
            <remarks>Очистить все значения словаря, вызвать для каждой записи событие изменения свойства</remarks>
        </member>
        <member name="T:MathCore.WPF.ViewModels.ViewModel">
            <summary>Визуальная объектная модель, представляющая механизм обработки событий изменения свойств</summary>
        </member>
        <member name="E:MathCore.WPF.ViewModels.ViewModel.PropertyChanged">
            <summary>Событие возникает когда изменяется значение свойства объекта</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.PropertyChanged_AddHandler(System.ComponentModel.PropertyChangedEventHandler)">
            <summary>Присоединить обработчик события <see cref="E:MathCore.WPF.ViewModels.ViewModel.PropertyChanged"/></summary>
            <param name="handler">Присоединяемый обработчик события <see cref="E:MathCore.WPF.ViewModels.ViewModel.PropertyChanged"/></param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.PropertyChanged_RemoveHandler(System.ComponentModel.PropertyChangedEventHandler)">
            <summary>Отсоединить обработчик события <see cref="E:MathCore.WPF.ViewModels.ViewModel.PropertyChanged"/></summary>
            <param name="handler">Отсоединяемый обработчик события <see cref="E:MathCore.WPF.ViewModels.ViewModel.PropertyChanged"/></param>
        </member>
        <member name="P:MathCore.WPF.ViewModels.ViewModel.IsDesignMode">
            <summary>Признак того, что мы находимся в режиме разработки под Visual Studio</summary>
        </member>
        <member name="F:MathCore.WPF.ViewModels.ViewModel._PropertiesDependenciesDictionary">
            <summary>Словарь графа зависимости изменений свойств</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.PropertyDependence_Add(System.String,System.String[])">
            <summary>Добавить зависимости между свойствами</summary>
            <param name="PropertyName">Имя исходного свойства</param>
            <param name="Dependences">Перечисление свойств, на которые исходное свойство имеет влияние</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.IsLoopDependency(System.String,System.String,System.String,System.Collections.Generic.Stack{System.String})">
            <summary>Проверка модели на циклические зависимости между свойствами</summary>
            <param name="property">Проверяемое свойство</param>
            <param name="dependence">Имя свойства зависимости</param>
            <param name="next_property">Следующее свойство в цепочке зависимости</param>
            <param name="invoke_stack">Стек вызова</param>
            <returns>Истина, если найден цикл</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.PropertyDependencies_Remove(System.String,System.String)">
            <summary>Удаление зависимости между свойствами</summary>
            <param name="PropertyName">Исходное свойство</param>
            <param name="Dependence">Свойство, связь с которым надо разорвать</param>
            <returns>Истина, если связь успешно удалена, ложь - если связь отсутствовала</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.PropertyDependencies_Clear(System.String)">
            <summary>Очистить граф зависимостей между свойствами для указанного свойства</summary>
            <param name="PropertyName">Название свойства, связи которого нао удалить</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.OnPropertyChanged(System.String,System.Boolean)">
            <summary>Генерация события изменения значения свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
            <param name="UpdateCommandsState">Обновить состояния <see cref="T:System.Windows.Input.ICommand"/></param>
        </member>
        <member name="F:MathCore.WPF.ViewModels.ViewModel._PropertyAsyncInvokeTime">
            <summary>Словарь, хранящий время последней генерации события изменения указанного свойства в асинхронном режиме</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.OnPropertyChangedAsync(System.String,System.Int32,System.Action,System.Action)">
            <summary>Асинхронная генерация события изменения свойства с возможностью указания таймаута ожидания повторных изменений</summary>
            <param name="PropertyName">Имя свойства</param>
            <param name="Timeout">Таймаут ожидания повторных изменений, прежде чем событие будет регенерировано</param>
            <param name="OnChanging">Метод, выполняемый до генерации события</param>
            <param name="OnChanged">Метод, выполняемый после генерации события</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.#ctor(System.Boolean)">
            <summary>Инициализация новой view-модели</summary><param name="CheckDependencies">Создавать карту зависимостей на основе атрибутов</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.Set``1(``0@,``0,System.ComponentModel.PropertyChangedEventHandler,System.Object,System.String)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="Sender">Объект-источник события</param>
            <param name="PropertyName">Имя свойства</param>
            <param name="OnPropertyChanged">Метод уведомления об изменении значения свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.Set``1(``0@,``0,System.String)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.Set``1(``0@,``0,``0@,System.String)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="OldValue">Предыдущее значение</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.Set``2(``0@,``1,System.Func{``1,``0},System.String)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="TField">Тип значения свойства</typeparam>
            <typeparam name="TValue">Тип значения, устанавливаемого для свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="converter">Метод преобразования значения</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.Set``1(``0@,``0,System.Func{``0,System.Boolean},System.String)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="ValueChecker">Метод проверки правильности устанавливаемого значения</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.Set``2(``0@,``1,System.Func{``1,``0},System.Func{``0,System.Boolean},System.String)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="TField">Тип значения свойства</typeparam>
            <typeparam name="TValue">Тип значения, получаемого из свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="converter">Метод преобразования значения</param>
            <param name="ValueChecker">Метод проверки правильности устанавливаемого значения</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.Set``1(``0@,``0,System.Boolean,System.String)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="UpdateCommandsState">Обновить состояния команд</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.SetAsync``1(``0@,``0,System.String)">
            <summary>Асинхронный метод изменения значения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="field">Поле, хранящее значение свойства</param>
            <param name="value">Новое значение свойства</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Задача, возвращающая истину, если свойство изменило своё значение</returns>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.Dispose">
            <inheritdoc />
        </member>
        <member name="F:MathCore.WPF.ViewModels.ViewModel._Disposed">
            <summary>Признак того, что объект уже уничтожен</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов</summary>
            <param name="disposing">Если истина, то требуется освободить управляемые объекты. Освободить неуправляемые объекты в любом случае</param>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.DisposeManagedObject">
            <summary>Освободить управляемые объекты</summary>
        </member>
        <member name="M:MathCore.WPF.ViewModels.ViewModel.DisposeUnmanagedObject">
            <summary>Освободить неуправляемые объекты</summary>
        </member>
        <member name="T:MathCore.WPF.Watermark">
            <summary>Водяной знак для поля ввода</summary>
        </member>
        <member name="F:MathCore.WPF.Watermark.OpacityProperty">
            <summary>Прозпачность возяного знака</summary>
        </member>
        <member name="M:MathCore.WPF.Watermark.SetOpacity(System.Windows.DependencyObject,System.Double)">
            <summary>Задать прозрачность возяного знака</summary>
            <param name="element">Объект, которому устанавливается прозрачность водяного знака</param>
            <param name="value">Значение прозрачности водяного знака</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.GetOpacity(System.Windows.DependencyObject)">
            <summary>Получить значение прозрачности водяного знака</summary>
            <param name="element">Элемент, прозрачность водяного знака которого надо получить</param>
            <returns>Значение прозрачности водяного знака</returns>
        </member>
        <member name="F:MathCore.WPF.Watermark.ValueProperty">
            <summary>Значение водяного знака</summary>
        </member>
        <member name="M:MathCore.WPF.Watermark.SetValue(System.Windows.DependencyObject,System.Object)">
            <summary>Задать значение водяного знака</summary>
            <param name="element">Элемент, которому задаётся значение водяного знака</param>
            <param name="value">Значение водяного знака</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.GetValue(System.Windows.DependencyObject)">
            <summary>Получить значение водяного знака</summary>
            <param name="element">Элемент, значение водяного знака которого надо получить</param>
            <returns>Значение водяного знака</returns>
        </member>
        <member name="F:MathCore.WPF.Watermark.VerticalAlignmentProperty">
            <summary>Прилогаемое свойство <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.VerticalAlignmentProperty"/> типа <see cref="T:System.Windows.VerticalAlignment"/></summary>
        </member>
        <member name="M:MathCore.WPF.Watermark.SetVerticalAligment(System.Windows.DependencyObject,System.Windows.VerticalAlignment)">
            <summary>Установка значения <see cref="!:value"/> типа <see cref="T:System.Windows.VerticalAlignment"/> свйоству <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.VerticalAlignmentProperty"/> целевого объекта <see cref="!:element"/></summary>
            <param name="element">Объект <see cref="T:System.Windows.DependencyObject"/>, значение <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.VerticalAlignmentProperty"/> которого надо установить</param>
            <param name="value">Устанавливаемое значение <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.VerticalAlignmentProperty"/> типа <see cref="T:System.Windows.VerticalAlignment"/></param>
        </member>
        <member name="M:MathCore.WPF.Watermark.GetVerticalAligment(System.Windows.DependencyObject)">
            <summary>Получение значения типа <see cref="T:System.Windows.VerticalAlignment"/> свойства <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.VerticalAlignmentProperty"/> у целевого объекта <see cref="!:element"/></summary>
            <param name="element">Объект <see cref="T:System.Windows.DependencyObject"/>, значение <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.VerticalAlignmentProperty"/> которого надо получить</param>
            <returns>Значение свйоства <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.VerticalAlignmentProperty"/> типа <see cref="T:System.Windows.VerticalAlignment"/> целевого объекта <see cref="!:element"/></returns>
        </member>
        <member name="F:MathCore.WPF.Watermark.HorizontalAlignmentProperty">
            <summary>Прилогаемое свойство <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.HorizontalAlignmentProperty"/> типа <see cref="T:System.Windows.HorizontalAlignment"/></summary>
        </member>
        <member name="M:MathCore.WPF.Watermark.SetHorizontalAlignment(System.Windows.DependencyObject,System.Windows.HorizontalAlignment)">
            <summary>Установка значения <see cref="!:value"/> типа <see cref="T:System.Windows.HorizontalAlignment"/> свйоству <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.HorizontalAlignmentProperty"/> целевого объекта <see cref="!:element"/></summary>
            <param name="element">Объект <see cref="T:System.Windows.DependencyObject"/>, значение <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.HorizontalAlignmentProperty"/> которого надо установить</param>
            <param name="value">Устанавливаемое значение <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.HorizontalAlignmentProperty"/> типа <see cref="T:System.Windows.HorizontalAlignment"/></param>
        </member>
        <member name="M:MathCore.WPF.Watermark.GetHorizontalAlignment(System.Windows.DependencyObject)">
            <summary>Получение значения типа <see cref="T:System.Windows.HorizontalAlignment"/> свойства <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.HorizontalAlignmentProperty"/> у целевого объекта <see cref="!:element"/></summary>
            <param name="element">Объект <see cref="T:System.Windows.DependencyObject"/>, значение <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.HorizontalAlignmentProperty"/> которого надо получить</param>
            <returns>Значение свйоства <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.HorizontalAlignmentProperty"/> типа <see cref="T:System.Windows.HorizontalAlignment"/> целевого объекта <see cref="!:element"/></returns>
        </member>
        <member name="F:MathCore.WPF.Watermark.FontSizeProperty">
            <summary>Прилогаемое свойство <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.FontSizeProperty"/> типа <see cref="T:System.Double"/></summary>
        </member>
        <member name="M:MathCore.WPF.Watermark.SetFontSize(System.Windows.DependencyObject,System.Double)">
            <summary>Установка значения <see cref="!:value"/> типа <see cref="T:System.Double"/> свйоству <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.FontSizeProperty"/> целевого объекта <see cref="!:element"/></summary>
            <param name="element">Объект <see cref="T:System.Windows.DependencyObject"/>, значение <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.FontSizeProperty"/> которого надо установить</param>
            <param name="value">Устанавливаемое значение <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.FontSizeProperty"/> типа <see cref="T:System.Double"/></param>
        </member>
        <member name="M:MathCore.WPF.Watermark.GetFontSize(System.Windows.DependencyObject)">
            <summary>Получение значения типа <see cref="T:System.Double"/> свойства <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.FontSizeProperty"/> у целевого объекта <see cref="!:element"/></summary>
            <param name="element">Объект <see cref="T:System.Windows.DependencyObject"/>, значение <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.FontSizeProperty"/> которого надо получить</param>
            <returns>Значение свйоства <see cref="T:MathCore.WPF.Watermark"/>.<see cref="F:MathCore.WPF.Watermark.FontSizeProperty"/> типа <see cref="T:System.Double"/> целевого объекта <see cref="!:element"/></returns>
        </member>
        <member name="F:MathCore.WPF.Watermark.__ItemsControlsDictionary">
            <summary>Словарь объектов ItemsControls, которым установлен водяной знак</summary>
        </member>
        <member name="M:MathCore.WPF.Watermark.OnWatermarkOpacityChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>Обработчик события изменения водяного знака</summary>
            <param name="d"><see cref="T:System.Windows.DependencyObject"/> - источник события</param>
            <param name="e"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs"/> - аргумент события изменения водяного знака</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.OnWatermarkPropertyAttached(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>Обработчик события изменения водяного знака</summary>
            <param name="d"><see cref="T:System.Windows.DependencyObject"/> - источник события</param>
            <param name="e"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs"/> - аргумент события изменения водяного знака</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.OnContentChanged(System.Object,System.Windows.RoutedEventArgs)">
            <summary>Обработчик события изменения фокуса ввода элемента</summary>
            <param name="sender">Объект - источник событий</param>
            <param name="e"><see cref="T:System.Windows.Controls.Primitives.ItemsChangedEventArgs"/> - аргумент события</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.OnGotKeyboardFocus(System.Object,System.Windows.RoutedEventArgs)">
            <summary>Обработчик события изменения фокуса ввода клавиатуры</summary>
            <param name="sender">Объект - источник событий</param>
            <param name="e"><see cref="T:System.Windows.RoutedEventArgs"/> - аргумент события</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.OnLoaded(System.Object,System.Windows.RoutedEventArgs)">
            <summary>Обработчик события загрузки компонента</summary>
            <param name="sender">Источник события</param>
            <param name="e"><see cref="T:System.Windows.RoutedEventArgs"/> - аргумент события</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.OnItemsSourceChanged(System.Object,System.EventArgs)">
            <summary>Обработчик события изменения значения свойства Источника элементов</summary>
            <param name="sender">Источник события</param>
            <param name="e">A <see cref="T:System.EventArgs"/> - аргумент события</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.OnItemsChanged(System.Object,System.Windows.Controls.Primitives.ItemsChangedEventArgs)">
            <summary>Обработчик события изменения элементов объекта</summary>
            <param name="sender">Источник события</param>
            <param name="e"><see cref="T:System.Windows.Controls.Primitives.ItemsChangedEventArgs"/> - аргумент события</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.RemoveWatermark(System.Windows.UIElement)">
            <summary>Уделить водяной знак элемента</summary>
            <param name="control">Элемент, водяной знак у которого надо удалить</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.ShowWatermark(System.Windows.Controls.Control)">
            <summary>Показать водяной знак для компонента</summary>
            <param name="control">Компонент, для которого надо показать водяной знак</param>
        </member>
        <member name="M:MathCore.WPF.Watermark.ShouldShowWatermark(System.Windows.Controls.Control)">
            <summary>Проверка необходимости показать водяной знак компонента</summary>
            <param name="control"><see cref="T:System.Windows.Controls.Control"/> - компонент, для которого надо проверить видимость</param>
            <returns>Истина, если компонент удовлетворяет условию отображения водяного знака</returns>
        </member>
        <member name="T:MathCore.WPF.Watermark.WatermarkAdorner">
            <summary>Слой водяного знака</summary>
        </member>
        <member name="F:MathCore.WPF.Watermark.WatermarkAdorner._ContentPresenter">
            <summary><see cref="T:System.Windows.Controls.ContentPresenter"/> - объект, содержащий водяной знак</summary>
        </member>
        <member name="M:MathCore.WPF.Watermark.WatermarkAdorner.#ctor(System.Windows.UIElement,System.Object)">
            <summary>Инициализация нового <see cref="T:MathCore.WPF.Watermark.WatermarkAdorner"/></summary>
            <param name="control"><see cref="T:System.Windows.UIElement"/> - компонент, которому назначается водяной знак</param>
            <param name="watermark">Значение водяного знака</param>
        </member>
        <member name="P:MathCore.WPF.Watermark.WatermarkAdorner.VisualChildrenCount">
            <summary>Число дочерних слоёв <see cref="T:System.Windows.Media.ContainerVisual"/></summary>
        </member>
        <member name="P:MathCore.WPF.Watermark.WatermarkAdorner.Control">
            <summary>Космонент, который надо отобразить</summary>
        </member>
        <member name="M:MathCore.WPF.Watermark.WatermarkAdorner.GetVisualChild(System.Int32)">
            <summary>
            Возвращает специальный тип дочернего <see cref="T:System.Windows.Media.Visual"/> для родительского <see cref="T:System.Windows.Media.ContainerVisual"/>.
            </summary>
            <param name="index">Индекс дочернего <see cref="T:System.Windows.Media.Visual"/>. Значение индекса должно быть между 0 и <see cref="P:MathCore.WPF.Watermark.WatermarkAdorner.VisualChildrenCount"/> - 1</param>
            <returns>Дочерний <see cref="T:System.Windows.Media.Visual"/></returns>
        </member>
        <member name="M:MathCore.WPF.Watermark.WatermarkAdorner.MeasureOverride(System.Windows.Size)">
            <summary> Реализует любое ручное поведение процесса измерения слоя</summary>
            <param name="constraint">Необходимый размер</param>
            <returns><see cref="T:System.Windows.Size"/> - размер нужного для отображения слоя</returns>
        </member>
        <member name="M:MathCore.WPF.Watermark.WatermarkAdorner.ArrangeOverride(System.Windows.Size)">
            <summary>
            При переопределении в производном классе размещает дочерние элементы и определяет размер для класса, производного от <see cref="T:System.Windows.FrameworkElement"/>. 
            </summary>
            <returns>Реальный используемый размер</returns>
            <param name="FinalSize">Итоговая область в родительском элементе, которую этот элемент должен использовать для собственного размещения и размещения своих дочерних элементов.</param>
        </member>
        <member name="T:MathCore.WPF.XAML">
            <summary>Генератор содержимого по указанному файлу разметки XAML</summary>
        </member>
        <member name="P:MathCore.WPF.XAML.URI">
            <summary>Указатель на источник разметки</summary>
        </member>
        <member name="M:MathCore.WPF.XAML.#ctor">
            <summary>Инициализация нового генератора разметки</summary>
        </member>
        <member name="M:MathCore.WPF.XAML.#ctor(System.String)">
            <summary>Инициализация нового генератора разметки</summary>
            <param name="URI">Указатель на источник разметки</param>
        </member>
        <member name="M:MathCore.WPF.XAML.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="F:System.Collections.Generic.ObservableLinkedList`1._List">
            <summary>Связный список элементов</summary>
        </member>
        <member name="P:System.Collections.Generic.ObservableLinkedList`1.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="P:System.Collections.Generic.ObservableLinkedList`1.First">
            <summary>Первый элемент списка</summary>
        </member>
        <member name="P:System.Collections.Generic.ObservableLinkedList`1.Last">
            <summary>Последний элемент списка</summary>
        </member>
        <member name="M:System.Collections.Generic.ObservableLinkedList`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.Collections.Generic.ObservableLinkedList`1"/></summary>
        </member>
        <member name="M:System.Collections.Generic.ObservableLinkedList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Инициализация нового экземпляра <see cref="T:System.Collections.Generic.ObservableLinkedList`1"/></summary>
            <param name="collection">Исходная последовательность элементов, добавляемая в список при инициализации</param>
        </member>
        <member name="M:System.Collections.Generic.ObservableLinkedList`1.AddAfter(System.Collections.Generic.LinkedListNode{`0},`0)">
            <summary>Добавить элемент после указанного элемента</summary>
            <param name="PrevNode">Элемент, после которого надо добавить значение в список</param>
            <param name="value">Добавляемое значение</param>
            <returns>Новый элемент списка</returns>
        </member>
        <member name="M:System.Collections.Generic.ObservableLinkedList`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:System.Collections.Generic.ObservableLinkedList`1.OnDeserialization(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:System.Windows.FrameworkElementExtensions">
            <summary>Класс методов-расширений для класса FrameworkElement</summary>
        </member>
        <member name="T:System.Threading.Tasks.NotifyTaskCompletion`1">
            <summary>Класс объектов, извещающих об завершении получения значения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
        </member>
        <member name="E:System.Threading.Tasks.NotifyTaskCompletion`1.PropertyChanged">
            <summary>Событие возникает при изменении значения свойства</summary>
        </member>
        <member name="F:System.Threading.Tasks.NotifyTaskCompletion`1._Task">
            <summary>Задача получения значения свойства</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.Task">
            <summary>Задача получения значения свойства</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.Result">
            <summary>Результат задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.Status">
            <summary>Статус задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.IsCompleted">
            <summary>Признак завершения задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.IsNotCompleted">
            <summary>Признак незавершённости задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.IsSuccessfullyCompleted">
            <summary>Признак успешного завершения задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.IsCanceled">
            <summary>Признак отмены задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.IsFaulted">
            <summary>Признак наличия ошибки при выполнении задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.Exception">
            <summary>Ошибки, полученные в результате выполнения задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.InnerException">
            <summary>Ошибка, породившая основное исключение</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.InnerExceptions">
            <summary>Список произошедших исключений</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.ErrorMessage">
            <summary>Сообщение об ошибке</summary>
        </member>
        <member name="M:System.Threading.Tasks.NotifyTaskCompletion`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>Инициализация экземпляра объекта, следящего за выполнением задачи получения значений</summary>
            <param name="task">Задача получения значения</param>
        </member>
        <member name="M:System.Threading.Tasks.NotifyTaskCompletion`1.WatchTaskAsync(System.Threading.Tasks.Task)">
            <summary>Метод слежения за задачей</summary>
            <param name="task">Отслеживаемая задача получения значения</param>
            <returns>Задача отслеживания задачи получения данных</returns>
        </member>
        <member name="M:System.Threading.Tasks.WPFTaskEx.FromDispatcherAsync">
            <summary>
            Метод вызывает завершение работы текущего метода в текущем контексте синхронизации и возвращает задачу, результатом которой является диспетчер исходного контекста синхронизации
            </summary>
            <returns>Задача, возвращающая диспетчер исходного контекста синхронизации в одном из потоков из пула потоков</returns>
        </member>
        <member name="M:System.Threading.Tasks.WPFTaskEx.WaitWithPumping(System.Threading.Tasks.Task)">
            <summary>Waits for the task to complete execution, pumping in the meantime.</summary>
            <param name="task">The task for which to wait.</param>
            <remarks>This method is intended for usage with Windows Presentation Foundation.</remarks>
        </member>
    </members>
</doc>
